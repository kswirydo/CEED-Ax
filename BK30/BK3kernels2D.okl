// 2D kernels in this file
#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)

#if p_gjNq==8 || p_gjNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif

#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

#define p_G00ID 0
#define p_G01ID 1
#define p_G02ID 2
#define p_G11ID 3
#define p_G12ID 4
#define p_G22ID 5
#define p_GWJID 6

//kernel 1 from paper

kernel void ellipticAxHex3D_Ref2D1(int Nelements,
				   datafloat * gjGeo,
				   datafloat * gjD,
				   datafloat *  gjI,
				   datafloat lambda,
				   datafloat *  q,
				   datafloat * Ixq,
				   datafloat *  Aq
				   ){

  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];
    shared datafloat s_tmpq[p_gjNq][p_gjNq];
    shared datafloat s_qr[p_gjNq][p_gjNq];
    shared datafloat s_qs[p_gjNq][p_gjNq];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    exclusive datafloat r_qt;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];
      }
    }

    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){

          datafloat tmp = 0;

          if(a<p_Nq && b<p_Nq){

            for(int c=0;c<p_Nq;++c){
              tmp += s_I[k][c]*q[e*p_Np+c*p_Nq2+b*p_Nq+a]; // r_lapq[c];
            }
          }

          s_tmpq[b][a] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          if(b<p_Nq){

            for(int a=0;a<p_Nq;++a){
              tmp += s_I[i][a]*s_tmpq[b][a];
            }
          }

          s_qr[b][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          for(int b=0;b<p_Nq;++b){
            tmp += s_I[j][b]*s_qr[b][i];
          }

          r_tmpq[k] = tmp;
        }
      }
    }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)
          r_lapq[k] = 0;

    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1)
        for(int i=0;i<p_gjNq;++i;inner0)
          s_tmpq[j][i] = r_tmpq[k];

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

          const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

          // differentiate
          datafloat qr = 0, qs = 0, qt = 0;

          for(int n=0;n<p_gjNq;++n){
            qr += s_D[i][n]*s_tmpq[j][n];
            qs += s_D[j][n]*s_tmpq[n][i];
            qt += s_D[k][n]*r_tmpq[n];
          }

          // apply chain rule (notice the swtich of indices in i,j)

          s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
          s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
          r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

          r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
        }
      }

      barrier(localMemFence);

      // weak diff
      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat lapqr = 0, lapqs = 0;

          for(int n=0;n<p_gjNq;++n){
            lapqr += s_D[n][i]*s_qr[j][n];
            lapqs += s_D[n][j]*s_qs[n][i];
          }

          for(int n=0;n<p_gjNq;++n){
            r_lapq[n] += s_D[k][n]*r_qt;
          }

          r_lapq[k] += lapqr + lapqs;
        }
      }
    }

    // now interpolate back in 't'
    for(int c=0;c<p_Nq;++c){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          for(int k=0;k<p_gjNq;++k){
            tmp += s_I[k][c]*r_lapq[k];
          }

          s_tmpq[j][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){
          if(b<p_Nq){

            datafloat tmp = 0;

            for(int j=0;j<p_gjNq;++j){
              tmp += s_I[j][b]*s_tmpq[j][i];
            }

            s_qr[b][i] = tmp;
          }
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){

          const int t = a + b*p_gjNq;

          if(t<p_Nq2){

            const int ta = t%p_Nq;
            const int tb = t/p_Nq;
            datafloat tmp = 0;

            for(int i=0;i<p_gjNq;++i){
              tmp += s_I[i][ta]*s_qr[tb][i];
            }

            const int id = e*p_Np + c*p_Nq2 + tb*p_Nq + ta;
            Aq[id] = tmp;
          }
        }
      }
    }
  }
} 

//Kernel 2 - const, prefetch q to regs

kernel void ellipticAxHex3D_Ref2D2(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gjD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   datafloat * restrict q,
				   datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];
    shared datafloat s_tmpq[p_gjNq][p_gjNq];
    shared datafloat s_qr[p_gjNq][p_gjNq];
    shared datafloat s_qs[p_gjNq][p_gjNq];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    exclusive datafloat r_qt;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];

        if(a<p_Nq && b<p_Nq){

          for(int c=0;c<p_Nq;++c){
            r_lapq[c] = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
          }
        } 
      }
    }

    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){

          datafloat tmp = 0;

          if(a<p_Nq && b<p_Nq){

            for(int c=0;c<p_Nq;++c){
              tmp += s_I[k][c]*r_lapq[c];
            }
          }

          s_tmpq[b][a] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          if(b<p_Nq){

            for(int a=0;a<p_Nq;++a){
              tmp += s_I[i][a]*s_tmpq[b][a];
            }
          }

          s_qr[b][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          for(int b=0;b<p_Nq;++b){
            tmp += s_I[j][b]*s_qr[b][i];
          }

          r_tmpq[k] = tmp;
        }
      }
    }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)
          r_lapq[k] = 0;

    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1)
        for(int i=0;i<p_gjNq;++i;inner0)
          s_tmpq[j][i] = r_tmpq[k];

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

          const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

          // differentiate
          datafloat qr = 0, qs = 0, qt = 0;

          for(int n=0;n<p_gjNq;++n){
            qr += s_D[i][n]*s_tmpq[j][n];
            qs += s_D[j][n]*s_tmpq[n][i];
            qt += s_D[k][n]*r_tmpq[n];
          }

          // apply chain rule (notice the swtich of indices in i,j)
          s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
          s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
          r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

          r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
        }
      }

      barrier(localMemFence);

      // weak diff
      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat lapqr = 0, lapqs = 0;

          for(int n=0;n<p_gjNq;++n){
            lapqr += s_D[n][i]*s_qr[j][n];
            lapqs += s_D[n][j]*s_qs[n][i];
          }

          for(int n=0;n<p_gjNq;++n){
            r_lapq[n] += s_D[k][n]*r_qt;
          }

          r_lapq[k] += lapqr + lapqs;
        }
      }
    }

    // now interpolate back in 't'
    for(int c=0;c<p_Nq;++c){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          for(int k=0;k<p_gjNq;++k){
            tmp += s_I[k][c]*r_lapq[k];
          }

          s_tmpq[j][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){
          if(b<p_Nq){

            datafloat tmp = 0;

            for(int j=0;j<p_gjNq;++j){
              tmp += s_I[j][b]*s_tmpq[j][i];
            }

            s_qr[b][i] = tmp;
          }
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){
          const int t = a + b*p_gjNq;
          if(t<p_Nq2){

            const int ta = t%p_Nq;
            const int tb = t/p_Nq;
            datafloat tmp = 0;

            for(int i=0;i<p_gjNq;++i){
              tmp += s_I[i][ta]*s_qr[tb][i];
            }

            const int id = e*p_Np + c*p_Nq2 + tb*p_Nq + ta;
            Aq[id] = tmp;
          }
        }
      }
    }
  }
} 

//Kernel 3 - const variables, unrolling

kernel void ellipticAxHex3D_Ref2D3(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gjD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   datafloat * restrict q,
				   datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];

    shared datafloat s_tmpq[p_gjNq][p_gjNq];
    shared datafloat s_qr[p_gjNq][p_gjNq];
    shared datafloat s_qs[p_gjNq][p_gjNq];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    exclusive datafloat r_qt;

    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              r_lapq[c] = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
            }
        }
      }
    }

    occaUnroll(p_Nq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            datafloat tmp = 0;

            if(a<p_Nq && b<p_Nq){

              occaUnroll(p_Nq)
                for(int c=0;c<p_Nq;++c){
                  tmp += s_I[k][c]*r_lapq[c];
                }
            }

            s_tmpq[b][a] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            if(b<p_Nq){

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  tmp += s_I[i][a]*s_tmpq[b][a];
                }
            }

            s_qr[b][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int b=0;b<p_Nq;++b){
                tmp += s_I[j][b]*s_qr[b][i];
              }

            r_tmpq[k] = tmp;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)
          r_lapq[k] = 0;

    occaUnroll(p_gjNq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            s_tmpq[j][i] = r_tmpq[k];

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

            const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

            // differentiate
            datafloat qr = 0, qs = 0, qt = 0;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                qr += s_D[i][n]*s_tmpq[j][n];
                qs += s_D[j][n]*s_tmpq[n][i];
                qt += s_D[k][n]*r_tmpq[n];
              }

            // apply chain rule (notice the swtich of indices in i,j)
            s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
            s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
            r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

            r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0, lapqs = 0;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_D[n][i]*s_qr[j][n];
                lapqs += s_D[n][j]*s_qs[n][i];
              }

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                r_lapq[n] += s_D[k][n]*r_qt;
              }

            r_lapq[k] += lapqr + lapqs;
          }
        }
      }

    // now interpolate back in 't'
    occaUnroll(p_Nq)
      for(int c=0;c<p_Nq;++c){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_gjNq)
              for(int k=0;k<p_gjNq;++k){
                tmp += s_I[k][c]*r_lapq[k];
              }

            s_tmpq[j][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            if(b<p_Nq){

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int j=0;j<p_gjNq;++j){
                  tmp += s_I[j][b]*s_tmpq[j][i];
                }

              s_qr[b][i] = tmp;
            }
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            const int t = a + b*p_gjNq;
            if(t<p_Nq2){

              const int ta = t%p_Nq;
              const int tb = t/p_Nq;
              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][ta]*s_qr[tb][i];
                }

              const int id = e*p_Np + c*p_Nq2 + tb*p_Nq + ta;
              Aq[id] = tmp;
            }
          }
        }
      }
  }
} 

//Kernel 4 - padding

kernel void ellipticAxHex3D_Ref2D4(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gjD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   datafloat * restrict q,
				   datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    shared datafloat s_tmpq[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qs[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    exclusive datafloat r_qt;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              r_lapq[c] = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
            }
        }
      }
    }

    occaUnroll(p_Nq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            datafloat tmp = 0;

            if(a<p_Nq && b<p_Nq){

              occaUnroll(p_Nq)
                for(int c=0;c<p_Nq;++c){
                  tmp += s_I[k][c]*r_lapq[c];
                }
            }

            s_tmpq[b][a] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            if(b<p_Nq){

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  tmp += s_I[i][a]*s_tmpq[b][a];
                }
            }

            s_qr[b][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int b=0;b<p_Nq;++b){
                tmp += s_I[j][b]*s_qr[b][i];
              }

            r_tmpq[k] = tmp;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)

          r_lapq[k] = 0;

    occaUnroll(p_gjNq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            s_tmpq[j][i] = r_tmpq[k];

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

            const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

            // differentiate
            datafloat qr = 0, qs = 0, qt = 0;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                qr += s_D[i][n]*s_tmpq[j][n];
                qs += s_D[j][n]*s_tmpq[n][i];
                qt += s_D[k][n]*r_tmpq[n];
              }

            // apply chain rule (notice the swtich of indices in i,j)
            s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
            s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
            r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

            r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0, lapqs = 0;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_D[n][i]*s_qr[j][n];
                lapqs += s_D[n][j]*s_qs[n][i];
              }

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                r_lapq[n] += s_D[k][n]*r_qt;
              }

            r_lapq[k] += lapqr + lapqs;
          }
        }
      }

    // now interpolate back in 't'
    occaUnroll(p_Nq)
      for(int c=0;c<p_Nq;++c){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_gjNq)
              for(int k=0;k<p_gjNq;++k){
                tmp += s_I[k][c]*r_lapq[k];
              }

            s_tmpq[j][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            if(b<p_Nq){

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int j=0;j<p_gjNq;++j){
                  tmp += s_I[j][b]*s_tmpq[j][i];
                }

              s_qr[b][i] = tmp;
            }
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            const int t = a + b*p_gjNq;
            if(t<p_Nq2){

              const int ta = t%p_Nq;
              const int tb = t/p_Nq;

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][ta]*s_qr[tb][i];
                }

              const int id = e*p_Np + c*p_Nq2 + tb*p_Nq + ta;
              Aq[id] = tmp;
            }
          }
        }
      }
  }
} 

//Kernel 5 from paper - change the way of interpolation

kernel void ellipticAxHex3D_Ref2D5(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gllD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   const datafloat * restrict q,
				   const datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];

    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qs[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c

    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){

              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];

              s_q[c][j][a] = tmp; 
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){

              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];

              s_q[c][j][i] = tmp; // ok since only this thread
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                tmp += s_I[k][c]*r_q[c];
              }

            s_q[k][j][i] = tmp; // ok since only this thread
          }
      }
    }
    //===============================================now differentiate once interpolated
    barrier(localMemFence);

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    barrier(localMemFence);

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;

            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];
          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0.0f, lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){

                lapqr += s_gllD[n][i]*s_qr[j][n];
                lapqs += s_gllD[n][j]*s_qs[n][i];
                r_q[n] += s_gllD[k][n]*r_qt;
              }

            r_q[k] += lapqr + lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];
          }
      }
    }

    barrier(localMemFence);
    //======_==== now project =================================================
    // b -> c -> a

    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){

            datafloat tmp = 0.0f;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                tmp += s_I[j][b]*r_q[j];
              }

            s_q[k][b][i] = tmp; // ok since only this thread
          }
      }
    }

    barrier(localMemFence);
    // transform back in a

    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){

        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][a]*r_q[i];
                }

              s_q[k][b][a] =tmp;;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  tmp += s_I[k][c]*r_q[k];
                }

              Aq[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
            }//c
        }//if
      }//a
    }//b
  }//e
}

//Kernel 6 -  altered dif. is one kernel version of reg 3

kernel void ellipticAxHex3D_Ref2D6(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gllD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   const datafloat * restrict q,
				   const datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_D[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_tmpr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_tmps[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
    exclusive datafloat r_Aq[p_gjNq],  r_tmpt;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_D[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];
            }
        }
      }
    }

    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c

    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){

              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];

              s_q[c][j][a] = tmp;
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){

        if(c<p_Nq){

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){

              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];

              s_q[c][j][i] = tmp; 
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c)
                tmp += s_I[k][c]*r_q[c];

            s_q[k][j][i] = tmp;
          }
      }
    }

    barrier(localMemFence);

    for(int j=0; j<p_gjNq; ++j; inner1) {
      for(int i=0; i<p_gjNq; ++i; inner0) {

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            r_q[k] = s_q[k][j][i];
            r_Aq[k] = 0.f;
          }
      }
    }

    barrier(localMemFence);

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int gbase = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];

            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

            // hide shared latency behind t-derivative
            datafloat qtk = 0.f;
            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                qtk += s_D[k][n]*r_q[n];
              }
            r_qt = qtk;
          }
        }

        barrier(localMemFence);

        // process k-slice (first r- and s-derivatives)
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            datafloat qr = 0.f, qs = 0.f;

            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                qr += s_D[i][n]*s_q[k][j][n];
                qs += s_D[j][n]*s_q[k][n][i];
              }

            // assumes w*J built into r_G entries
            s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
            s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
            r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

            r_Aq[k] += r_GwJ*lambda*r_q[k];

            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                r_Aq[n] += s_D[k][n]*r_tmpt;
              }
          }
        }

        barrier(localMemFence);

        // second derivatives
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            datafloat Aq1 = 0.0f, Aq2 = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                Aq1 += s_D[n][i]*s_tmpr[j][n];
                Aq2 += s_D[n][j]*s_tmps[n][i];
              }

            r_Aq[k] +=  Aq1 + Aq2;
          }
        }
      }
    barrier(localMemFence);
    // write result out (local node storage)
    for(int j=0; j<p_gjNq; ++j; inner1) {
      for(int i=0; i<p_gjNq; ++i; inner0) {

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) 
            s_q[k][j][i] = r_Aq[k];          
      }
    }

    //kernel 3 project back --------------------------------------------------------

    barrier(localMemFence);
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){

            datafloat tmp = 0.0f;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                tmp += s_I[j][b]*r_q[j];
              }

            s_q[k][b][i] = tmp; // ok since only this thread
          }
      }
    }

    barrier(localMemFence);

    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner0){

        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i)
                  tmp += s_I[i][a]*r_q[i];

              s_q[k][b][a] =tmp;;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k)
              r_q[k] = s_q[k][b][a];

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k)
                  tmp += s_I[k][c]*r_q[k];

              Aq[e*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
            }//c
        }//if
      }//a
    }//b
  }//e
}

//Kernel 7 - elliminate one shared memory array

kernel void ellipticAxHex3D_Ref2D7(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gllD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   const datafloat * restrict q,
				   const datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){

          for(int c=0;c<p_gjNq;++c){
            s_q[c][b][a] =0.0f;
          }
        }
      }
    }

    barrier(localMemFence);

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c

    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){

              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];

              s_q[c][j][a] = tmp; 
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){

        if(c<p_Nq){

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){
              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];

              s_q[c][j][i] = tmp;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c)
                tmp += s_I[k][c]*r_q[c];

            s_q[k][j][i] = tmp;
          }
      }
    }

    barrier(localMemFence);

    //===============================================now differentiate once interpolated

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    barrier(localMemFence);

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {

        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;

            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];
          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                r_q[n] += s_gllD[k][n]*r_qt;
              }

            r_q[k] += lapqr;
          }
        }

        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            s_qr[j][i] = r_qs;
          }
        }

        barrier(localMemFence);
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n)
                lapqs += s_gllD[n][j]*s_qr[n][i];

            r_q[k] += lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) 
            s_q[k][j][i] = r_q[k];  
      }
    }

    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)

          for(int j=0;j<p_gjNq;++j)
            r_q[j] = s_q[k][j][i];

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){

            datafloat tmp = 0.0f;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j)
                tmp += s_I[j][b]*r_q[j];

            s_q[k][b][i] = tmp;
          }
      }
    }

    barrier(localMemFence);
    // transform back in a

    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){

        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i)
                  tmp += s_I[i][a]*r_q[i];

              s_q[k][b][a] =tmp;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k)
              r_q[k] = s_q[k][b][a];

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k)
                  tmp += s_I[k][c]*r_q[k];

              Aq[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
            }//c
        }//if
      }//a
    }//b
  }//e
}//kernel

//kernel 8 - two D matrices, D and D'

kernel void ellipticAxHex3D_Ref2D8(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gllD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   const datafloat * restrict q,
				   datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_gllDT[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];
        s_gllDT[b][a] = gllD[a*p_gjNq+b];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c

    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){

              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];

              s_q[c][j][a] = tmp;
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){

        if(c<p_Nq){

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){

              datafloat tmp = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];

              s_q[c][j][i] = tmp;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c)
                tmp += s_I[k][c]*r_q[c];

            s_q[k][j][i] = tmp;
          }
      }
    }

    //===============================================now differentiate once interpolated

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {

        barrier(localMemFence);
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;

            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllDT[n][i]*s_q[k][j][n];
                ds += s_gllDT[n][j]*s_q[k][n][i];
                dt += s_gllDT[n][k]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;

            r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;
            r_q[k] += lambda*r_GwJ*s_q[k][j][i];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                r_q[n] += s_gllDT[n][k]*r_qt;
              }

            r_q[k] += lapqr;
          }
        }

        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            s_qr[j][i] = r_qs;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n)
                lapqs += s_gllD[n][j]*s_qr[n][i];

            r_q[k] += lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) 
            s_q[k][j][i] = r_q[k];
      }
    }

    barrier(localMemFence);

    //=========== now project =================================================
    // b -> c -> a

    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j)
            r_q[j] = s_q[k][j][i];

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){

            datafloat tmp = 0.0f;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j)
                tmp += s_I[j][b]*r_q[j];

            s_q[k][b][i] = tmp;
          }
      }
    }

    barrier(localMemFence);

    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){

        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i)
                  tmp += s_I[i][a]*r_q[i];

              s_q[k][b][a] =tmp;;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k)
              r_q[k] = s_q[k][b][a];

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k)
                  tmp += s_I[k][c]*r_q[k];

              Aq[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
            }//c
        }//if
      }//a
    }//b
  }//e
}//kernel

//Kernel 9 - reduce shared memory fetches

kernel void ellipticAxHex3D_Ref2D9(const int Nelements,
				   const datafloat * restrict gjGeo,
				   const datafloat * restrict gllD,
				   const datafloat * restrict gjI,
				   const datafloat lambda,
				   const datafloat * restrict q,
				   const datafloat * restrict Ixq,
				   datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c

    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){

                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp;
              s_q[c][p_gjNq-1-j][a] = tmp2;
            }
        }
      }
    }//for c

    barrier(localMemFence);

    //transform in c    
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){

        if(c<p_Nq){

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)

              r_q[a] = s_q[c][j][a];

          occaUnroll(p_halfD)
            for(int i=0;i<p_halfD;++i){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){

                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }

              s_q[c][j][i] = tmp; 
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){

                const datafloat sIkc = s_I[k][c];
                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }

            s_q[k][j][i] = tmp; // ok since only this thread
            s_q[p_gjNq-k-1][j][i] = tmp2;
          }
      }
    }
    //===============================================now differentiate once interpolated

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    barrier(localMemFence);

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {

        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;

            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;

            r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];
          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                r_q[n] += s_gllD[k][n]*r_qt;
              }

            r_q[k] += lapqr;
          }
        }

        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            s_qr[j][i] = r_qs;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqs += s_gllD[n][j]*s_qr[n][i];
              }

            r_q[k] += lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];
          }
      }
    }

    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){

            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0f;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){

                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }

            s_q[k][b][i] = tmp; 
            s_q[k][p_Nq-b-1][i] = tmp2;
          }
      }
    }

    barrier(localMemFence);
    // transform back in a

    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){

                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }

              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){

                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[e*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}//kernel

//kernel 10 - reduced shared memory fetches

kernel void ellipticAxHex3D_Ref2D10(const int Nelements,
				    const datafloat * restrict gjGeo,
				    const datafloat * restrict gllD,
				    const datafloat * restrict gjI,
				    const datafloat lambda,
				    const datafloat * restrict q,
				    const datafloat * restrict Ixq,
				    datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qs[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c

    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){

                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp;
              s_q[c][p_gjNq-1-j][a] = tmp2;
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_halfD)
            for(int i=0;i<p_halfD;++i){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){

                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }

              s_q[c][j][i] = tmp; 
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){

                const datafloat sIkc = s_I[k][c];
                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }

            s_q[k][j][i] = tmp; // ok since only this thread
            s_q[p_gjNq-k-1][j][i] = tmp2;
          }
      }
    }
    //===============================================now differentiate once interpolated

    barrier(localMemFence);

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)

            r_q[k] =0.0f;

    barrier(localMemFence);
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;

            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;

            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;
            r_q[k] += lambda*r_GwJ*s_q[k][j][i];

          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0.0f, lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                lapqs += s_gllD[n][j]*s_qs[n][i];
                r_q[n] += s_gllD[k][n]*r_qt;
              }

            r_q[k] += lapqr + lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];
          }
      }
    }

    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){

            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){

                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }

            s_q[k][b][i] = tmp;
            s_q[k][p_Nq-b-1][i] = tmp2;
          }
      }
    }

    barrier(localMemFence);

    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){

        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){

                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }

              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){

                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[e*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}//kernel

//Kernel 11 - experimental best diff, best interp TOGETHER

kernel void ellipticAxHex3D_Ref2D11(const int Nelements,
				    const datafloat * restrict gjGeo,
				    const datafloat * restrict gllD,
				    const datafloat * restrict gjI,
				    const datafloat lambda,
				    const datafloat * restrict q,
				    const datafloat * restrict Ixq,
				    datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];
    shared datafloat s_v[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_w[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_Aq[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_tmp, r_GDut, r_Auk;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c

    // transform in b    
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){

                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp; // ok since only this thread
              s_q[c][p_gjNq-1-j][a] = tmp2;
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){

        if(c<p_Nq){

          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_halfD)

            for(int i=0;i<p_halfD;++i){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }

              s_q[c][j][i] = tmp; // ok since only this thread
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){

                const datafloat sIkc = s_I[k][c];

                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }

            s_q[k][j][i] = tmp; // ok since only this thread
            s_q[p_gjNq-k-1][j][i] = tmp2;
          }
      }
    }

    //================== differentiate

    barrier(localMemFence);
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        for (int k=0; k<p_gjNq;++k){
          r_q[k] = s_q[k][j][i];
          r_Aq[k] = 0.0f;
        }
      }
    }

    barrier(localMemFence);

    // Layer by layer
    occaUnroll(p_gjNq)
      for(int k = 0;k < p_gjNq; k++){
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int gbase = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];

            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];

            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            r_tmp = 0;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                r_tmp += s_gllD[k][m]*r_q[m];
              }
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat ur = 0.f;
            datafloat us = 0.f;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                ur += s_gllD[i][m]*s_q[k][j][m];
                us += s_gllD[j][m]*s_q[k][m][i];
              }

            s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_tmp);
            s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_tmp);

            r_GDut = (r_G02*ur + r_G12*us + r_G22*r_tmp);

            r_Auk = r_GwJ*lambda*r_q[k];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++){
                r_Auk   += s_gllD[m][j]*s_w[m][i];
                r_Aq[m] += s_gllD[k][m]*r_GDut; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_gllD[m][i]*s_v[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_Aq[k];
          }
      }
    }

    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){

            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){

                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }

            s_q[k][b][i] = tmp; // ok since only this thread
            s_q[k][p_Nq-b-1][i] = tmp2;
          }
      }
    }

    barrier(localMemFence);

    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){

        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }

              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[e*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}//Kernel

//Kernel 12 - use registers in place of shared memory

kernel void ellipticAxHex3D_Ref2D12(const int Nelements,
				    const datafloat * restrict gjGeo,
				    const datafloat * restrict gllD,
				    const datafloat * restrict gjI,
				    const datafloat lambda,
				    const datafloat * restrict q,
				    const datafloat * restrict Ixq,
				    datafloat * restrict Aq){

  for(int e=0; e<Nelements; ++e; outer0) {

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];

    shared datafloat s_v[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_w[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_Aq[p_gjNq];
    exclusive datafloat r_D[p_gjNq];

    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_tmp, r_GDut, r_Auk;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c

    //transform in b
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){

                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp;
              s_q[c][p_gjNq-1-j][a] = tmp2;
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){

        if(c<p_Nq){

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          occaUnroll(p_halfD)
            for(int i=0;i<p_halfD;++i){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){

                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }

              s_q[c][j][i] = tmp; 
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){

                const datafloat sIkc = s_I[k][c];
                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }

            s_q[k][j][i] = tmp; 
            s_q[p_gjNq-k-1][j][i] = tmp2;
          }
      }
    }

    //================== differentiate

    barrier(localMemFence);

    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        for (int k=0; k<p_gjNq;++k){
          r_q[k] = s_q[k][j][i];
          r_Aq[k] = 0.0f;
        }
      }
    }

    barrier(localMemFence);

    // Layer by layer
    occaUnroll(p_gjNq)
      for(int k = 0;k < p_gjNq; k++){
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int gbase = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];

            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];

            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            // share u(:,:,k)

            r_tmp = 0;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                r_D[m] = s_gllD[k][m];
                r_tmp += r_D[m]*r_q[m];
              }
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat ur = 0.f;
            datafloat us = 0.f;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                ur += s_gllD[i][m]*s_q[k][j][m];
                us += s_gllD[j][m]*s_q[k][m][i];
              }

            s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_tmp);
            s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_tmp);

            r_GDut = (r_G02*ur + r_G12*us + r_G22*r_tmp);

            r_Auk = r_GwJ*lambda*r_q[k];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++){
                r_Auk   += s_gllD[m][j]*s_w[m][i];
                r_Aq[m] += r_D[m]*r_GDut; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_gllD[m][i]*s_v[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_Aq[k];
          }
      }
    }

    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){

            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){

                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }

            s_q[k][b][i] = tmp; // ok since only this thread
            s_q[k][p_Nq-b-1][i] = tmp2;
          }
      }
    }

    barrier(localMemFence);

    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){

        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }

              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;
            }
        }
      }
    }

    barrier(localMemFence);

    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){

                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[e*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[e*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}

//Kernel 13 - use only 2D shared (performance is not satisfactory)

kernel void ellipticAxHex3D_Ref2D13(const int Nelements,
				    const datafloat * restrict gjGeo,
				    const datafloat * restrict gjD,
				    const datafloat * restrict gjI,
				    const datafloat lambda,
				    datafloat * restrict q,
				    datafloat * restrict Ixq,
				    datafloat * restrict Aq){

  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    shared datafloat s_u[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_v[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_w[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_Aq[p_gjNq];

    exclusive datafloat r_ut, r_GDut, r_Auk;
    datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    exclusive datafloat r_qt;

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];

        if(a<p_Nq && b<p_Nq){

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              r_Aq[c] = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
            }
        }
      }
    }

    occaUnroll(p_gjNq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            datafloat tmp = 0;

            if(a<p_Nq && b<p_Nq){

              occaUnroll(p_Nq)
                for(int c=0;c<p_Nq;++c)
                  tmp += s_I[k][c]*r_Aq[c];
            }
            s_u[b][a] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            if(b<p_Nq){

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*s_u[b][a];
            }
            s_v[b][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int b=0;b<p_Nq;++b)
                tmp += s_I[j][b]*s_v[b][i];

            r_q[k] = tmp;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k){
          r_Aq[k] = 0;
        }
    //DIFFERENTIATE =========================================

    occaUnroll(p_gjNq)
      for(int k = 0;k < p_gjNq; k++){

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int gbase = e*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];

            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];

            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            // share u(:,:,k)
            s_u[j][i] = r_q[k];

            r_ut = 0;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                r_ut += s_D[k][m]*r_q[m];
              }
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat ur = 0.f;
            datafloat us = 0.f;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                ur += s_D[i][m]*s_u[j][m];
                us += s_D[j][m]*s_u[m][i];
              }

            s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_ut);
            s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_ut);

            r_GDut = (r_G02*ur + r_G12*us + r_G22*r_ut);

            r_Auk = r_GwJ*lambda*r_q[k];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++){
                r_Auk   += s_D[m][j]*s_w[m][i];
                r_Aq[m] += s_D[k][m]*r_GDut; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_D[m][i]*s_v[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }

    // now interpolate back in 't'
    occaUnroll(p_Nq)
      for(int c=0;c<p_Nq;++c){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_gjNq)
              for(int k=0;k<p_gjNq;++k)
                tmp += s_I[k][c]*r_Aq[k];

            s_u[j][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            if(b<p_Nq){

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int j=0;j<p_gjNq;++j)
                  tmp += s_I[j][b]*s_u[j][i];

              s_v[b][i] = tmp;
            }
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){
            const int t = a + b*p_gjNq;
            if(t<p_Nq2){

              const int ta = t%p_Nq;
              const int tb = t/p_Nq;

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i)
                  tmp += s_I[i][ta]*s_v[tb][i];

              const int id = e*p_Np + c*p_Nq2 + tb*p_Nq + ta;

              Aq[id] = tmp;
            }
          }
        }
      }
  }
}


