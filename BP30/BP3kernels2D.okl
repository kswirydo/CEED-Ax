// 2D kernels in this file
#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)

#if p_gjNq==8 || p_gjNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif

#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif


#define p_G00ID 0
#define p_G01ID 1
#define p_G02ID 2
#define p_G11ID 3
#define p_G12ID 4
#define p_G22ID 5
#define p_GWJID 6

//no opt.

//kernel 1 from paper
kernel void ellipticAxHex3D_Ref2D1(int Nelements,
    datafloat * gjGeo,
    datafloat * gjD,
    datafloat *  gjI,
    datafloat lambda,
    datafloat *  q,
    datafloat * Ixq,
    datafloat *  Aq
    )
{
  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    shared datafloat s_tmpq[p_gjNq][p_gjNq];

    shared datafloat s_qr[p_gjNq][p_gjNq];
    shared datafloat s_qs[p_gjNq][p_gjNq];

    exclusive int emap;
    exclusive datafloat r_qt;

    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        const int t = a + p_gjNq*b;
        s_D[b][a] = gjD[b*p_gjNq+a];
        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];
      }
    }

    //  //occaUnroll(p_Nq)
    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){

          datafloat tmp = 0;

          if(a<p_Nq && b<p_Nq){
            //      //occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              tmp += s_I[k][c]*q[emap*p_Np+c*p_Nq2+b*p_Nq+a]; // r_lapq[c];
            }
          }
          s_tmpq[b][a] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){
          datafloat tmp = 0;

          if(b<p_Nq){
            for(int a=0;a<p_Nq;++a){
              tmp += s_I[i][a]*s_tmpq[b][a];
            }
          }
          s_qr[b][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;
          for(int b=0;b<p_Nq;++b){
            tmp += s_I[j][b]*s_qr[b][i];
          }
          r_tmpq[k] = tmp;
        }
      }
    }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)
          r_lapq[k] = 0;

    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1)
        for(int i=0;i<p_gjNq;++i;inner0)
          s_tmpq[j][i] = r_tmpq[k];

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

          // differentiate
          datafloat qr = 0, qs = 0, qt = 0;
          for(int n=0;n<p_gjNq;++n){
            qr += s_D[i][n]*s_tmpq[j][n];
            qs += s_D[j][n]*s_tmpq[n][i];
            qt += s_D[k][n]*r_tmpq[n];
          }

          // apply chain rule (notice the swtich of indices in i,j)
          s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
          s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
          r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

          r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
        }
      }

      barrier(localMemFence);

      // weak diff
      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){
          datafloat lapqr = 0, lapqs = 0;

          for(int n=0;n<p_gjNq;++n){
            lapqr += s_D[n][i]*s_qr[j][n];
            lapqs += s_D[n][j]*s_qs[n][i];
          }
          for(int n=0;n<p_gjNq;++n){
            r_lapq[n] += s_D[k][n]*r_qt;
          }

          r_lapq[k] += lapqr + lapqs;
        }
      }
    }

    // now interpolate back in 't'
    for(int c=0;c<p_Nq;++c){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){
          datafloat tmp = 0;

          //occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){
            tmp += s_I[k][c]*r_lapq[k];
          }

          s_tmpq[j][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){
          if(b<p_Nq){
            datafloat tmp = 0;

            for(int j=0;j<p_gjNq;++j){
              tmp += s_I[j][b]*s_tmpq[j][i];
            }

            s_qr[b][i] = tmp;
          }
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){
          const int t = a + b*p_gjNq;
          if(t<p_Nq2){
            const int ta = t%p_Nq;
            const int tb = t/p_Nq;
            datafloat tmp = 0;

            for(int i=0;i<p_gjNq;++i){
              tmp += s_I[i][ta]*s_qr[tb][i];
            }

            const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
            Aq[id] = tmp;
          }
        }
      }
    }
  }
} //REF0 ends


//REF1 - const, prefetch q to regs
//kernel 2 from paper
kernel void ellipticAxHex3D_Ref2D2(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gjD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    shared datafloat s_tmpq[p_gjNq][p_gjNq];

    shared datafloat s_qr[p_gjNq][p_gjNq];
    shared datafloat s_qs[p_gjNq][p_gjNq];

    exclusive int emap;
    exclusive datafloat r_qt;

    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        const int t = a + p_gjNq*b;
        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];
        if(a<p_Nq && b<p_Nq){
          // prefetch q(a,b,:) to registers
          for(int c=0;c<p_Nq;++c){
            r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
          }
        } 
      }
    }

    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){

          datafloat tmp = 0;

          if(a<p_Nq && b<p_Nq){
            for(int c=0;c<p_Nq;++c){
              tmp += s_I[k][c]*r_lapq[c];
            }
          }
          s_tmpq[b][a] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          if(b<p_Nq){
            for(int a=0;a<p_Nq;++a){
              tmp += s_I[i][a]*s_tmpq[b][a];
            }
          }
          s_qr[b][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          for(int b=0;b<p_Nq;++b){
            tmp += s_I[j][b]*s_qr[b][i];
          }
          r_tmpq[k] = tmp;
        }
      }
    }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)
          r_lapq[k] = 0;

    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1)
        for(int i=0;i<p_gjNq;++i;inner0)
          s_tmpq[j][i] = r_tmpq[k];

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

          // differentiate
          datafloat qr = 0, qs = 0, qt = 0;

          for(int n=0;n<p_gjNq;++n){
            qr += s_D[i][n]*s_tmpq[j][n];
            qs += s_D[j][n]*s_tmpq[n][i];
            qt += s_D[k][n]*r_tmpq[n];
          }

          // apply chain rule (notice the swtich of indices in i,j)
          s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
          s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
          r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

          r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
        }
      }

      barrier(localMemFence);

      // weak diff
      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat lapqr = 0, lapqs = 0;

          for(int n=0;n<p_gjNq;++n){
            lapqr += s_D[n][i]*s_qr[j][n];
            lapqs += s_D[n][j]*s_qs[n][i];
          }
          for(int n=0;n<p_gjNq;++n){
            r_lapq[n] += s_D[k][n]*r_qt;
          }

          r_lapq[k] += lapqr + lapqs;
        }
      }
    }

    // now interpolate back in 't'
    for(int c=0;c<p_Nq;++c){

      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){

          datafloat tmp = 0;

          for(int k=0;k<p_gjNq;++k){
            tmp += s_I[k][c]*r_lapq[k];
          }

          s_tmpq[j][i] = tmp;
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int i=0;i<p_gjNq;++i;inner0){
          if(b<p_Nq){

            datafloat tmp = 0;

            for(int j=0;j<p_gjNq;++j){
              tmp += s_I[j][b]*s_tmpq[j][i];
            }

            s_qr[b][i] = tmp;
          }
        }
      }

      barrier(localMemFence);

      for(int b=0;b<p_gjNq;++b;inner1){
        for(int a=0;a<p_gjNq;++a;inner0){
          const int t = a + b*p_gjNq;
          if(t<p_Nq2){

            const int ta = t%p_Nq;
            const int tb = t/p_Nq;
            datafloat tmp = 0;

            for(int i=0;i<p_gjNq;++i){
              tmp += s_I[i][ta]*s_qr[tb][i];
            }

            const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
            Aq[id] = tmp;
          }
        }
      }
    }
  }
} //REF1 ends

// REF 2 DO UNROLLLL


//REF1 - const, prefetch q to regs

//kernel 3 from paper
kernel void ellipticAxHex3D_Ref2D3(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gjD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    shared datafloat s_tmpq[p_gjNq][p_gjNq];

    shared datafloat s_qr[p_gjNq][p_gjNq];
    shared datafloat s_qs[p_gjNq][p_gjNq];

    exclusive int emap;
    exclusive datafloat r_qt;

    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;

        const int t = a + p_gjNq*b;

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];

        if(a<p_Nq && b<p_Nq){
          // prefetch q(a,b,:) to registers
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
            }
        }
      }
    }

    occaUnroll(p_Nq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            datafloat tmp = 0;

            if(a<p_Nq && b<p_Nq){
              occaUnroll(p_Nq)
                for(int c=0;c<p_Nq;++c){
                  tmp += s_I[k][c]*r_lapq[c];
                }
            }
            s_tmpq[b][a] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            if(b<p_Nq){
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  tmp += s_I[i][a]*s_tmpq[b][a];
                }
            }
            s_qr[b][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int b=0;b<p_Nq;++b){
                tmp += s_I[j][b]*s_qr[b][i];
              }
            r_tmpq[k] = tmp;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)
          r_lapq[k] = 0;

    occaUnroll(p_gjNq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            s_tmpq[j][i] = r_tmpq[k];

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
            const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

            // differentiate
            datafloat qr = 0, qs = 0, qt = 0;
            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                qr += s_D[i][n]*s_tmpq[j][n];
                qs += s_D[j][n]*s_tmpq[n][i];
                qt += s_D[k][n]*r_tmpq[n];
              }

            // apply chain rule (notice the swtich of indices in i,j)
            s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
            s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
            r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

            r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat lapqr = 0, lapqs = 0;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_D[n][i]*s_qr[j][n];
                lapqs += s_D[n][j]*s_qs[n][i];
              }
            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                r_lapq[n] += s_D[k][n]*r_qt;
              }

            r_lapq[k] += lapqr + lapqs;
          }
        }
      }

    // now interpolate back in 't'
    occaUnroll(p_Nq)
      for(int c=0;c<p_Nq;++c){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_gjNq)
              for(int k=0;k<p_gjNq;++k){
                tmp += s_I[k][c]*r_lapq[k];
              }

            s_tmpq[j][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            if(b<p_Nq){

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int j=0;j<p_gjNq;++j){
                  tmp += s_I[j][b]*s_tmpq[j][i];
                }

              s_qr[b][i] = tmp;
            }
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){
            const int t = a + b*p_gjNq;
            if(t<p_Nq2){

              const int ta = t%p_Nq;
              const int tb = t/p_Nq;
              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][ta]*s_qr[tb][i];
                }

              const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
              Aq[id] = tmp;
            }
          }
        }
      }
  }
} //REF2 ends

//REF3 padding

kernel void ellipticAxHex3D_Ref2D4(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gjD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive datafloat r_lapq[p_gjNq];
    exclusive datafloat r_tmpq[p_gjNq];

    shared datafloat s_tmpq[p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qs[p_gjNq][p_gjNq+p_gjPad];

    exclusive int emap;
    exclusive datafloat r_qt;

    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;

        const int t = a + p_gjNq*b;

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];

        if(a<p_Nq && b<p_Nq){
          // prefetch q(a,b,:) to registers
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              r_lapq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
            }
        }
      }
    }

    occaUnroll(p_Nq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            datafloat tmp = 0;

            if(a<p_Nq && b<p_Nq){
              occaUnroll(p_Nq)
                for(int c=0;c<p_Nq;++c){
                  tmp += s_I[k][c]*r_lapq[c];
                }
            }
            s_tmpq[b][a] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            if(b<p_Nq){
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  tmp += s_I[i][a]*s_tmpq[b][a];
                }
            }
            s_qr[b][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int b=0;b<p_Nq;++b){
                tmp += s_I[j][b]*s_qr[b][i];
              }
            r_tmpq[k] = tmp;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k)

          r_lapq[k] = 0;

    occaUnroll(p_gjNq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            s_tmpq[j][i] = r_tmpq[k];

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            const datafloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
            const datafloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            const datafloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            const datafloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            const datafloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            const datafloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            const datafloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

            // differentiate
            datafloat qr = 0, qs = 0, qt = 0;
            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                qr += s_D[i][n]*s_tmpq[j][n];
                qs += s_D[j][n]*s_tmpq[n][i];
                qt += s_D[k][n]*r_tmpq[n];
              }

            // apply chain rule (notice the swtich of indices in i,j)
            s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
            s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
            r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

            r_lapq[k] += lambda*r_GwJ*r_tmpq[k];
          }
        }

        barrier(localMemFence);

        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0, lapqs = 0;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_D[n][i]*s_qr[j][n];
                lapqs += s_D[n][j]*s_qs[n][i];
              }
            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                r_lapq[n] += s_D[k][n]*r_qt;
              }
            r_lapq[k] += lapqr + lapqs;
          }
        }
      }

    // now interpolate back in 't'
    occaUnroll(p_Nq)
      for(int c=0;c<p_Nq;++c){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat tmp = 0;

            occaUnroll(p_gjNq)
              for(int k=0;k<p_gjNq;++k){
                tmp += s_I[k][c]*r_lapq[k];
              }

            s_tmpq[j][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            if(b<p_Nq){

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int j=0;j<p_gjNq;++j){
                  tmp += s_I[j][b]*s_tmpq[j][i];
                }
              s_qr[b][i] = tmp;
            }
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){
            const int t = a + b*p_gjNq;
            if(t<p_Nq2){
              const int ta = t%p_Nq;
              const int tb = t/p_Nq;
              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][ta]*s_qr[tb][i];
                }

              const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
              Aq[id] = tmp;
            }
          }
        }
      }
  }
} //REF2 ends






//REF4 - change the way of interpolation
//kernel 5 from paper
kernel void ellipticAxHex3D_Ref2D5(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    const datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0; e<Nelements; ++e; outer0) {

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
    //save the SHARED
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qs[p_gjNq][p_gjNq+p_gjPad];
    // LOAD TO SHAEWS
    exclusive int emap;

    // prefetch D and I matrices and zero register storage
    //LOOP 1
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }
    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c
    // rrrrrrr
    //Loop 2
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          // transform in b
          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];
              s_q[c][j][a] = tmp; // ok since only this thread
            }
        }
      }
    }//for c

    barrier(localMemFence);
    //Loop 3
    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];
              s_q[c][j][i] = tmp; // ok since only this thread
            }
        }
      }
    }
    //now synch
    barrier(localMemFence);
    //Loop4
    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                tmp += s_I[k][c]*r_q[c];
              }
            s_q[k][j][i] = tmp; // ok since only this thread
          }
      }
    }
    //===============================================now differentiate once interpolated
    //Loop 5
    barrier(localMemFence);
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    barrier(localMemFence);
    //Loop6
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);
        //Loop6-1
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;

            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];

          }
        }

        barrier(localMemFence);
        //Loop 6-2
        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0.0f, lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                lapqs += s_gllD[n][j]*s_qs[n][i];
                r_q[n] += s_gllD[k][n]*r_qt;
              }
            r_q[k] += lapqr + lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];
          }
      }
    }

    // ALL CORRECT UNTIL THIS POINT
    barrier(localMemFence);
    //======_==== now project =================================================
    // b -> c -> a

    //Loop 8
    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){
            datafloat tmp = 0.0f;
            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                tmp += s_I[j][b]*r_q[j];
              }
            s_q[k][b][i] = tmp; // ok since only this thread
          }
      }
    }

    barrier(localMemFence);
    //Loop 9
    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a){
              datafloat tmp = 0.0f;
              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][a]*r_q[i];
                }

              s_q[k][b][a] =tmp;;
            }
        }
      }
    }
    //Loop 10
    barrier(localMemFence);
    //shared datafloat s_I[p_gjNq][p_Nq];
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              datafloat tmp = 0.0f;
              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  tmp += s_I[k][c]*r_q[k];
                }

              Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
            }//c
        }//if
      }//a
    }//b
  }//e
}//REF4 ends

//kernel 6 from paper
//Ref2D5 - altered dif. is one kernel version of reg 3
kernel void ellipticAxHex3D_Ref2D6(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    const datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){


  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
    //save the SHARED
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_tmpr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_tmps[p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_D[p_gjNq][p_gjNq+p_gjPad];

    exclusive datafloat r_Aq[p_gjNq],  r_tmpt;

    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qs[p_gjNq][p_gjNq+p_gjPad];
    exclusive int emap;

    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;

        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_D[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];
            }
        }
      }
    }

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c

    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          // transform in b
          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];
              s_q[c][j][a] = tmp; // ok since only this thread
            }
        }
      }
    }//for c

    barrier(localMemFence);

    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){

        if(c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];
              s_q[c][j][i] = tmp; // ok since only this thread
            }
        }
      }
    }
    //now synch
    barrier(localMemFence);
    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                tmp += s_I[k][c]*r_q[c];

              }

            s_q[k][j][i] = tmp; // ok since only this thread

          }
      }
    }

    barrier(localMemFence);
    // prefetch q(i,j,:,e) to register array
    for(int j=0; j<p_gjNq; ++j; inner1) {
      for(int i=0; i<p_gjNq; ++i; inner0) {

        emap = e;

        const int base = i + j*p_gjNq + emap*p_gjNp;

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            r_q[k] = s_q[k][j][i];
            r_Aq[k] = 0.f;
          }
      }
    }

    barrier(localMemFence);

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int gbase = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

            // hide shared latency behind t-derivative
            datafloat qtk = 0.f;
            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                qtk += s_D[k][n]*r_q[n];
              }
            r_qt = qtk;
          }
        }

        barrier(localMemFence);

        // process k-slice (first r- and s-derivatives)
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            datafloat qr = 0.f, qs = 0.f;

            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                qr += s_D[i][n]*s_q[k][j][n];
                qs += s_D[j][n]*s_q[k][n][i];
              }

            // assumes w*J built into r_G entries
            s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
            s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
            r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

            r_Aq[k] += r_GwJ*lambda*r_q[k];

            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                r_Aq[n] += s_D[k][n]*r_tmpt;
              }
          }
        }

        barrier(localMemFence);

        // second derivatives
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            datafloat Aq1 = 0.0f, Aq2 = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0; n<p_gjNq; ++n) {
                Aq1 += s_D[n][i]*s_tmpr[j][n];
                Aq2 += s_D[n][j]*s_tmps[n][i];
              }

            r_Aq[k] +=  Aq1 + Aq2;
          }
        }
      }
    barrier(localMemFence);
    // write result out (local node storage)
    for(int j=0; j<p_gjNq; ++j; inner1) {
      for(int i=0; i<p_gjNq; ++i; inner0) {
        int id = emap*p_gjNp + j*p_gjNq + i;
        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {

            s_q[k][j][i] = r_Aq[k];

          }
      }
    }

    //kernel 3 project back --------------------------------------------------------

    barrier(localMemFence);
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){
            datafloat tmp = 0.0f;
            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                tmp += s_I[j][b]*r_q[j];
              }
            s_q[k][b][i] = tmp; // ok since only this thread
          }
      }
    }

    barrier(localMemFence);

    // transform back in a
    occaUnroll(p_gjNq)
      for(int k=0;k<p_gjNq;++k;inner1){
        barrier(localMemFence);
        for(int b=0;b<p_gjNq;++b;inner0){
          if(b<p_Nq){
            occaUnroll(p_gjNq)
              for(int i=0;i<p_gjNq;++i)
                r_q[i] = s_q[k][b][i];

            occaUnroll(p_Nq)
              for(int a=0;a<p_Nq;++a){
                datafloat tmp = 0.0f;
                occaUnroll(p_gjNq)
                  for(int i=0;i<p_gjNq;++i){
                    tmp += s_I[i][a]*r_q[i];
                  }
                s_q[k][b][a] =tmp;;
              }
          }
        }
      }

    barrier(localMemFence);
    //shared datafloat s_I[p_gjNq][p_Nq];
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          //occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){
            r_q[k] = s_q[k][b][a];
          }

          //occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c){
            datafloat tmp = 0.0f;
            occaUnroll(p_gjNq)
              for(int k=0;k<p_gjNq;++k){
                tmp += s_I[k][c]*r_q[k];
              }

            Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
          }//c
        }//if
      }//a
    }//b
  }//e
}//REF5 ends

//REF6
//one less shared array
//kernel 7 from paper
kernel void ellipticAxHex3D_Ref2D7(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    const datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0; e<Nelements; ++e; outer0) {

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;
    //save the SHARED
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive int emap;

    // prefetch D and I matrices and zero register storage

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          for(int c=0;c<p_gjNq;++c){
            s_q[c][b][a] =0.0f;
          }
        }
      }
    }
    barrier(localMemFence);
    //LOOP 1
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c
    //Loop 2
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          // transform in b
          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];
              s_q[c][j][a] = tmp; // ok since only this thread
            }
        }
      }
    }//for c

    barrier(localMemFence);

    //Loop 3
    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];
              s_q[c][j][i] = tmp; // ok since only this thread
            }
        }
      }
    }

    //now synch
    barrier(localMemFence);
    //Loop4

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                tmp += s_I[k][c]*r_q[c];
              }

            s_q[k][j][i] = tmp; // ok since only this thread

          }
      }
    }

    barrier(localMemFence);

    //===============================================now differentiate once interpolated
    //Loop 5

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    barrier(localMemFence);
    //Loop6
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);
        //Loop6-1
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;
            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];
          }
        }
        barrier(localMemFence);
        //Loop 6-2
        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqr = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                r_q[n] += s_gllD[k][n]*r_qt;
              }
            r_q[k] += lapqr;
          }
        }

        barrier(localMemFence);
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            s_qr[j][i] = r_qs;
          }
        }

        barrier(localMemFence);
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqs += s_gllD[n][j]*s_qr[n][i];
              }
            r_q[k] += lapqs;
            //+ lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];  
          }
      }
    }

    // ALL CORRECT UNTIL THIS POINT
    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    //Loop 8
    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){
            datafloat tmp = 0.0f;
            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                tmp += s_I[j][b]*r_q[j];
              }
            s_q[k][b][i] = tmp; // ok since only this thread
          }
      }
    }

    barrier(localMemFence);
    //Loop 9
    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a){
              datafloat tmp = 0.0f;
              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][a]*r_q[i];
                }
              s_q[k][b][a] =tmp;;
            }
        }
      }
    }
    //Loop 10
    barrier(localMemFence);
    //shared datafloat s_I[p_gjNq][p_Nq];
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          //occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){
            r_q[k] = s_q[k][b][a];
          }

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              datafloat tmp = 0.0f;
              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  tmp += s_I[k][c]*r_q[k];
                }

              Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
            }//c
        }//if
      }//a
    }//b
  }//e
}//kernel

// reg7

//two D matrices, D and DT

//kernel 8 from paper
kernel void ellipticAxHex3D_Ref2D8(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){

  for(int e=0; e<Nelements; ++e; outer0) {

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_gllDT[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive int emap;

    // prefetch D and I matrices and zero register storage
    //LOOP 1
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];
        s_gllDT[b][a] = gllD[a*p_gjNq+b];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c
    //Loop 2
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          // transform in b
          occaUnroll(p_gjNq)
            for(int j=0;j<p_gjNq;++j){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b)
                  tmp += s_I[j][b]*r_q[b];
              s_q[c][j][a] = tmp; // ok since only this thread
            }
        }
      }
    }//for c

    barrier(localMemFence);
    //Loop 3
    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i){
              datafloat tmp = 0;
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a)
                  tmp += s_I[i][a]*r_q[a];
              s_q[c][j][i] = tmp; // ok since only this thread
            }
        }
      }
    }

    //now synch
    barrier(localMemFence);
    //Loop4

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                tmp += s_I[k][c]*r_q[c];
              }
            s_q[k][j][i] = tmp; // ok since only this thread
          }
      }
    }

    //===============================================now differentiate once interpolated
    //Loop 5

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;


    //Loop6
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);
        //Loop6-1
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;
            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllDT[n][i]*s_q[k][j][n];
                ds += s_gllDT[n][j]*s_q[k][n][i];
                dt += s_gllDT[n][k]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];
          }
        }
        barrier(localMemFence);
        //Loop 6-2
        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat lapqr = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                r_q[n] += s_gllDT[n][k]*r_qt;
              }
            r_q[k] += lapqr;
          }
        }

        barrier(localMemFence);
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            s_qr[j][i] = r_qs;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqs += s_gllD[n][j]*s_qr[n][i];
              }

            r_q[k] += lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];
          }
      }
    }

    // ALL CORRECT UNTIL THIS POINT
    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    //Loop 8
    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_Nq)
          for(int b=0;b<p_Nq;++b){

            datafloat tmp = 0.0f;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                tmp += s_I[j][b]*r_q[j];
              }
            s_q[k][b][i] = tmp; // ok since only this thread
          }
      }
    }

    barrier(localMemFence);
    //Loop 9
    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a){

              datafloat tmp = 0.0f;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][a]*r_q[i];
                }
              s_q[k][b][a] =tmp;;
            }
        }
      }
    }
    //Loop 10
    barrier(localMemFence);
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              datafloat tmp = 0.0f;
              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  tmp += s_I[k][c]*r_q[k];
                }

              Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
            }//c
        }//if
      }//a
    }//b
  }//e
}//kernel REFG7


//REG8 ---> reduce shared fetches



//kernel 9 from paper
kernel void ellipticAxHex3D_Ref2D9(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    const datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0; e<Nelements; ++e; outer0) {

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive int emap;

    //LOOP 1
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        //a<p_Nq && b<p_gjNq
        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c
    // rrrrrrr
    //Loop 2
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          // transform in b
          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){
                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp; // ok since only this thread
              s_q[c][p_gjNq-1-j][a] = tmp2;
            }
        }
      }
    }//for c

    barrier(localMemFence);
    //Loop 3
    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_halfD)
            for(int i=0;i<p_halfD;++i){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }

              s_q[c][j][i] = tmp; // ok since only this thread
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }

    //now synch
    barrier(localMemFence);
    //Loop4
    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                const datafloat sIkc = s_I[k][c];
                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }

            s_q[k][j][i] = tmp; // ok since only this thread
            s_q[p_gjNq-k-1][j][i] = tmp2;

          }
      }
    }
    //===============================================now differentiate once interpolated
    //Loop 5

    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    barrier(localMemFence);
    //Loop6
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);
        //Loop6-1
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;
            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];
          }
        }
        barrier(localMemFence);
        //Loop 6-2
        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat lapqr = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                r_q[n] += s_gllD[k][n]*r_qt;
              }
            r_q[k] += lapqr;
          }
        }

        barrier(localMemFence);

        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {
            s_qr[j][i] = r_qs;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqs += s_gllD[n][j]*s_qr[n][i];
              }
            r_q[k] += lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];
            //  Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
          }
      }
    }

    // ALL CORRECT UNTIL THIS POINT
    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    //Loop 8
    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){

            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0f;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }

            s_q[k][b][i] = tmp; // ok since only this thread
            s_q[k][p_Nq-b-1][i] = tmp2;
          }
      }
    }

    barrier(localMemFence);
    //Loop 9
    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){
              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;
              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }
              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;

            }
        }
      }
    }
    //Loop 10
    barrier(localMemFence);
    //shared datafloat s_I[p_gjNq][p_Nq];
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){
              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;
              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[emap*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}//kernel REG8

//Ref2D9=Ref2D4+reduced shared fetches (experimental)


kernel void ellipticAxHex3D_Ref2D10(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    const datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0; e<Nelements; ++e; outer0) {

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];
    shared datafloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_qs[p_gjNq][p_gjNq+p_gjPad];

    exclusive int emap;

    // prefetch D and I matrices and zero register storage
    //LOOP 1
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }
        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }
    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c
    //Loop 2
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){
                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp; // ok since only this thread
              s_q[c][p_gjNq-1-j][a] = tmp2;
            }
        }
      }
    }//for c

    barrier(localMemFence);
    //Loop 3
    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_halfD)
            for(int i=0;i<p_halfD;++i){
              datafloat tmp = 0;
              datafloat tmp2 = 0;
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }
              s_q[c][j][i] = tmp; // ok since only this thread
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }
    //now synch
    barrier(localMemFence);
    //Loop4

    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_Nq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                const datafloat sIkc = s_I[k][c];
                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }
            s_q[k][j][i] = tmp; // ok since only this thread
            s_q[p_gjNq-k-1][j][i] = tmp2;

          }
      }
    }
    //===============================================now differentiate once interpolated
    //Loop 5
    barrier(localMemFence);
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k)
        for(int j=0;j<p_gjNq;++j;inner1)
          for(int i=0;i<p_gjNq;++i;inner0)
            r_q[k] =0.0f;

    barrier(localMemFence);
    //Loop6
    occaUnroll(p_gjNq)
      for(int k=0; k<p_gjNq; ++k) {
        barrier(localMemFence);
        //Loop6-1
        for(int j=0; j<p_gjNq; ++j; inner1) {
          for(int i=0; i<p_gjNq; ++i; inner0) {

            const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
            //geofactors for k j i thread
            r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
            r_G00 = gjGeo[base+p_G00ID*p_gjNp];
            r_G01 = gjGeo[base+p_G01ID*p_gjNp];
            r_G02 = gjGeo[base+p_G02ID*p_gjNp];

            r_G11 = gjGeo[base+p_G11ID*p_gjNp];
            r_G12 = gjGeo[base+p_G12ID*p_gjNp];
            r_G22 = gjGeo[base+p_G22ID*p_gjNp];
            // now, put together dq/dr, qq/ds, dq/dt and dq/dI

            datafloat dr = 0.0f;
            datafloat ds = 0.0f;
            datafloat dt = 0.0f;
            occaUnroll(p_gjNq)
              for (int n = 0; n<p_gjNq; ++n) {
                dr += s_gllD[i][n]*s_q[k][j][n];
                ds += s_gllD[j][n]*s_q[k][n][i];
                dt += s_gllD[k][n]*s_q[n][j][i];
              }

            s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
            s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
            r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

            r_q[k] += lambda*r_GwJ*s_q[k][j][i];

          }
        }

        barrier(localMemFence);
        //Loop 6-2
        // weak diff
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat lapqr = 0.0f, lapqs = 0.0f;

            occaUnroll(p_gjNq)
              for(int n=0;n<p_gjNq;++n){
                lapqr += s_gllD[n][i]*s_qr[j][n];
                lapqs += s_gllD[n][j]*s_qs[n][i];
                r_q[n] += s_gllD[k][n]*r_qt;
              }
            r_q[k] += lapqr + lapqs;
          }
        }
      }//k

    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_q[k];
          }
      }
    }

    // ALL CORRECT UNTIL THIS POINT
    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    //Loop 8
    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }
        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){

            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0;

            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }
            s_q[k][b][i] = tmp; // ok since only this thread
            s_q[k][p_Nq-b-1][i] = tmp2;

          }
      }
    }

    barrier(localMemFence);
    //Loop 9
    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){
              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;
              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }
              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;

            }
        }
      }
    }
    //Loop 10
    barrier(localMemFence);
    //shared datafloat s_I[p_gjNq][p_Nq];
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          //occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){
            r_q[k] = s_q[k][b][a];
          }
          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){
              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;
              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[emap*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}//REF9 ends


//REF10 - experimental best diff, best interp TOGETHER


kernel void ellipticAxHex3D_Ref2D11(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    const datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0; e<Nelements; ++e; outer0) {

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_Aq[p_gjNq];
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp, r_GDut, r_Auk;

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];

    shared datafloat s_v[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_w[p_gjNq][p_gjNq+p_gjPad];

    exclusive int emap;

    // prefetch D and I matrices and zero register storage
    //LOOP 1
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }
    //synch threads

    barrier(localMemFence);

    //============== interpolate in 3 dir ========================
    // b --> a --> c
    //Loop 2
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          // transform in b
          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){
                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp; // ok since only this thread
              s_q[c][p_gjNq-1-j][a] = tmp2;

            }
        }
      }
    }//for c

    barrier(localMemFence);
    //Loop 3
    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){

          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_halfD)
            for(int i=0;i<p_halfD;++i){
              datafloat tmp = 0;
              datafloat tmp2 = 0;
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }
              s_q[c][j][i] = tmp; // ok since only this thread
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }
    //now synch
    barrier(localMemFence);
    //Loop4
    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_gjNq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;
            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){

                const datafloat sIkc = s_I[k][c];

                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }

            s_q[k][j][i] = tmp; // ok since only this thread
            s_q[p_gjNq-k-1][j][i] = tmp2;

          }
      }
    }

    //================== differentiate

    barrier(localMemFence);
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        for (int k=0; k<p_gjNq;++k){
          r_q[k] = s_q[k][j][i];
          r_Aq[k] = 0.0f;
        }
      }
    }

    barrier(localMemFence);
    // Layer by layer
    occaUnroll(p_gjNq)
      for(int k = 0;k < p_gjNq; k++){
        //  barrier(localMemFence);
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int gbase = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            r_tmp = 0;
            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                r_tmp += s_gllD[k][m]*r_q[m];
              }
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat ur = 0.f;
            datafloat us = 0.f;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                ur += s_gllD[i][m]*s_q[k][j][m];
                us += s_gllD[j][m]*s_q[k][m][i];
              }

            s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_tmp);
            s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_tmp);

            // put this here for a performance bump
            r_GDut = (r_G02*ur + r_G12*us + r_G22*r_tmp);

            r_Auk = r_GwJ*lambda*r_q[k];

          }
        }
        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++){
                r_Auk   += s_gllD[m][j]*s_w[m][i];
                r_Aq[m] += s_gllD[k][m]*r_GDut; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_gllD[m][i]*s_v[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }



    //    barrier(localMemFence);

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_Aq[k];
          }
      }
    }

    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    //Loop 8
    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){
            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0;
            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }
            s_q[k][b][i] = tmp; // ok since only this thread
            s_q[k][p_Nq-b-1][i] = tmp2;

          }
      }
    }

    barrier(localMemFence);

    //Loop 9
    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){

          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){
              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;
              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }
              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;

            }
        }
      }
    }
    //Loop 10
    barrier(localMemFence);
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          //occaUnroll(p_gjNq)
          for(int k=0;k<p_gjNq;++k){
            r_q[k] = s_q[k][b][a];
          }

          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){

              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;

              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[emap*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}//REF10 ends


//REF11 -> registers not shared

kernel void ellipticAxHex3D_Ref2D12(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    const datafloat * restrict q,
    const datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0; e<Nelements; ++e; outer0) {

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_Aq[p_gjNq];
    exclusive datafloat r_D[p_gjNq];

    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp, r_GDut, r_Auk;
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq];

    shared datafloat s_v[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_w[p_gjNq][p_gjNq+p_gjPad];
    exclusive int emap;

    // prefetch D and I matrices and zero register storage
    //LOOP 1
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;
        if(a<p_Nq){
          s_I[b][a] = gjI[a+p_Nq*b];
        }

        s_gllD[b][a] = gllD[b*p_gjNq+a];

        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
            }
        }
      }
    }
    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // b --> a --> c
    //Loop 2
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && c<p_Nq){
          // prefetch to registers

          occaUnroll(p_Nq)
            for(int b=0;b<p_Nq;++b)
              r_q[b] = s_q[c][b][a];

          // transform in b
          occaUnroll(p_halfD)
            for(int j=0;j<p_halfD;++j){

              datafloat tmp = 0;
              datafloat tmp2 = 0;

              occaUnroll(p_Nq)
                for(int b=0;b<p_Nq;++b){
                  const datafloat sIjb= s_I[j][b];
                  tmp  += sIjb*r_q[b];
                  tmp2 += sIjb*r_q[p_Nq-1-b];
                }

              s_q[c][j][a] = tmp; // ok since only this thread
              s_q[c][p_gjNq-1-j][a] = tmp2;

            }
        }
      }
    }//for c

    barrier(localMemFence);
    //Loop 3
    // transform in a
    for(int c=0;c<p_gjNq;++c;inner1){
      for(int j=0;j<p_gjNq;++j;inner0){
        if(c<p_Nq){
          // prefetch to registers
          occaUnroll(p_Nq)
            for(int a=0;a<p_Nq;++a)
              r_q[a] = s_q[c][j][a];

          // transform in a
          occaUnroll(p_halfD)
            for(int i=0;i<p_halfD;++i){
              datafloat tmp = 0;
              datafloat tmp2 = 0;
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[a];
                  tmp2 += sIia*r_q[p_Nq-1-a];
                }
              s_q[c][j][i] = tmp; // ok since only this thread
              s_q[c][j][p_gjNq-1-i] = tmp2;
            }
        }
      }
    }
    //now synch
    barrier(localMemFence);
    //Loop4
    // transform in c
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        // prefetch to registers
        occaUnroll(p_gjNq)
          for(int c=0;c<p_Nq;++c)
            r_q[c] = s_q[c][j][i];

        // transform in c
        occaUnroll(p_halfD)
          for(int k=0;k<p_halfD;++k){

            datafloat tmp = 0;
            datafloat tmp2= 0;

            occaUnroll(p_Nq)
              for(int c=0;c<p_Nq;++c){
                const datafloat sIkc = s_I[k][c];
                tmp  += sIkc*r_q[c];
                tmp2 += sIkc*r_q[p_Nq-1-c] ;
              }
            s_q[k][j][i] = tmp; // ok since only this thread
            s_q[p_gjNq-k-1][j][i] = tmp2;

          }
      }
    }

    //================== differentiate

    barrier(localMemFence);
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        for (int k=0; k<p_gjNq;++k){
          r_q[k] = s_q[k][j][i];
          r_Aq[k] = 0.0f;
        }
      }
    }

    barrier(localMemFence);
    // Layer by layer
    occaUnroll(p_gjNq)
      for(int k = 0;k < p_gjNq; k++){
        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int gbase = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            // share u(:,:,k)

            r_tmp = 0;
            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                r_D[m] = s_gllD[k][m];
                r_tmp += r_D[m]*r_q[m];
              }
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat ur = 0.f;
            datafloat us = 0.f;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                ur += s_gllD[i][m]*s_q[k][j][m];
                us += s_gllD[j][m]*s_q[k][m][i];
              }

            s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_tmp);
            s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_tmp);

            // put this here for a performance bump
            r_GDut = (r_G02*ur + r_G12*us + r_G22*r_tmp);

            r_Auk = r_GwJ*lambda*r_q[k];
          }
        }
        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++){
                r_Auk   += s_gllD[m][j]*s_w[m][i];
                r_Aq[m] += r_D[m]*r_GDut; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_gllD[m][i]*s_v[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }

    //Loop 7
    for(int j=0;j<p_gjNq;++j;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){

        occaUnroll(p_gjNq)
          for(int k=0; k<p_gjNq; ++k) {
            s_q[k][j][i] = r_Aq[k];
          }
      }
    }

    barrier(localMemFence);
    //=========== now project =================================================
    // b -> c -> a

    //Loop 8
    // transform back in b
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int i=0;i<p_gjNq;++i;inner0){
        occaUnroll(p_gjNq)
          for(int j=0;j<p_gjNq;++j){
            r_q[j] = s_q[k][j][i];
          }

        occaUnroll(p_halfD)
          for(int b=0;b<p_halfD;++b){
            datafloat tmp = 0.0f;
            datafloat tmp2 = 0.0;
            occaUnroll(p_gjNq)
              for(int j=0;j<p_gjNq;++j){
                const datafloat sIjb = s_I[j][b];
                tmp  += sIjb*r_q[j];
                tmp2 += sIjb*r_q[p_gjNq-1-j];
              }
            s_q[k][b][i] = tmp; // ok since only this thread
            s_q[k][p_Nq-b-1][i] = tmp2;

          }
      }
    }

    barrier(localMemFence);

    barrier(localMemFence);
    //Loop 9
    // transform back in a
    for(int k=0;k<p_gjNq;++k;inner1){
      for(int b=0;b<p_gjNq;++b;inner0){
        if(b<p_Nq){
          occaUnroll(p_gjNq)
            for(int i=0;i<p_gjNq;++i)
              r_q[i] = s_q[k][b][i];

          occaUnroll(p_halfD)
            for(int a=0;a<p_halfD;++a){
              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;
              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  const datafloat sIia = s_I[i][a];
                  tmp  += sIia*r_q[i];
                  tmp2 += sIia*r_q[p_gjNq-1-i];
                }
              s_q[k][b][a] =tmp;
              s_q[k][b][p_Nq-1-a] = tmp2;

            }
        }
      }
    }
    //Loop 10
    barrier(localMemFence);
    //shared datafloat s_I[p_gjNq][p_Nq];
    // transform back in c
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
        if(a<p_Nq && b<p_Nq){
          occaUnroll(p_gjNq)
            for(int k=0;k<p_gjNq;++k){
              r_q[k] = s_q[k][b][a];
            }

          occaUnroll(p_halfD)
            for(int c=0;c<p_halfD;++c){
              datafloat tmp  = 0.0f;
              datafloat tmp2 = 0.0f;
              occaUnroll(p_gjNq)
                for(int k=0;k<p_gjNq;++k){
                  const datafloat sIkc = s_I[k][c];
                  tmp  += sIkc*r_q[k];
                  tmp2 += sIkc*r_q[p_gjNq-1-k];
                }

              Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
              Aq[emap*p_Np+(p_Nq-1-c)*p_Nq*p_Nq+b*p_Nq+a]  = tmp2;
            }//c
        }//if
      }//a
    }//b
  }//e
}

//ref11 ends

//REF12; goal: use only 2D shared; performance is bad

kernel void ellipticAxHex3D_Ref2D13(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gjD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  for(int e=0;e<Nelements;++e;outer0){

    shared datafloat s_D[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive datafloat r_q[p_gjNq];
    exclusive datafloat r_Aq[p_gjNq];

    shared datafloat s_u[p_gjNq][p_gjNq+p_gjPad];

    shared datafloat s_v[p_gjNq][p_gjNq+p_gjPad];
    shared datafloat s_w[p_gjNq][p_gjNq+p_gjPad];
    exclusive datafloat r_ut, r_GDut, r_Auk;
    datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;


    exclusive int emap;
    exclusive datafloat r_qt;

    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){

        emap = e;

        const int t = a + p_gjNq*b;

        s_D[b][a] = gjD[b*p_gjNq+a];

        if(a<p_Nq && b<p_gjNq)
          s_I[b][a] = gjI[b*p_Nq+a];

        if(a<p_Nq && b<p_Nq){
          // prefetch q(a,b,:) to registers
          occaUnroll(p_Nq)
            for(int c=0;c<p_Nq;++c){
              r_Aq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
            }
        }
      }
    }

    occaUnroll(p_gjNq)
      for(int k=0;k<p_gjNq;++k){

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){

            datafloat tmp = 0;

            if(a<p_Nq && b<p_Nq){
              occaUnroll(p_Nq)
                for(int c=0;c<p_Nq;++c){

                  tmp += s_I[k][c]*r_Aq[c];
                }
            }
            s_u[b][a] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            datafloat tmp = 0;

            if(b<p_Nq){
              occaUnroll(p_Nq)
                for(int a=0;a<p_Nq;++a){
                  tmp += s_I[i][a]*s_u[b][a];
                }
            }
            s_v[b][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_Nq)
              for(int b=0;b<p_Nq;++b){
                tmp += s_I[j][b]*s_v[b][i];
              }
            r_q[k] = tmp;
          }
        }
      }

    for(int j=0;j<p_gjNq;++j;inner1)
      for(int i=0;i<p_gjNq;++i;inner0)
        for(int k=0;k<p_gjNq;++k){
          r_Aq[k] = 0;
        }
    //DIFFERENTIATE =========================================
    // Layer by layer
    occaUnroll(p_gjNq)
      for(int k = 0;k < p_gjNq; k++){

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            const int gbase = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

            r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
            r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
            r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
            r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
            r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
            r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
            r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            // share u(:,:,k)
            s_u[j][i] = r_q[k];

            r_ut = 0;
            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                r_ut += s_D[k][m]*r_q[m];
              }
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat ur = 0.f;
            datafloat us = 0.f;

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++) {
                ur += s_D[i][m]*s_u[j][m];
                us += s_D[j][m]*s_u[m][i];
              }

            s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_ut);
            s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_ut);

            // put this here for a performance bump
            r_GDut = (r_G02*ur + r_G12*us + r_G22*r_ut);

            r_Auk = r_GwJ*lambda*r_q[k];
          }
        }

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            occaUnroll(p_gjNq)
              for(int m = 0; m < p_gjNq; m++){
                r_Auk   += s_D[m][j]*s_w[m][i];
                r_Aq[m] += s_D[k][m]*r_GDut; // DT(m,k)*ut(i,j,k,e)
                r_Auk   += s_D[m][i]*s_v[j][m];
              }

            r_Aq[k] += r_Auk;
          }
        }
      }
    // now interpolate back in 't'
    occaUnroll(p_Nq)
      for(int c=0;c<p_Nq;++c){

        barrier(localMemFence);

        for(int j=0;j<p_gjNq;++j;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){

            datafloat tmp = 0;

            occaUnroll(p_gjNq)
              for(int k=0;k<p_gjNq;++k){
                tmp += s_I[k][c]*r_Aq[k];
              }

            s_u[j][i] = tmp;
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int i=0;i<p_gjNq;++i;inner0){
            if(b<p_Nq){

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int j=0;j<p_gjNq;++j){
                  tmp += s_I[j][b]*s_u[j][i];
                }

              s_v[b][i] = tmp;
            }
          }
        }

        barrier(localMemFence);

        for(int b=0;b<p_gjNq;++b;inner1){
          for(int a=0;a<p_gjNq;++a;inner0){
            const int t = a + b*p_gjNq;
            if(t<p_Nq2){

              const int ta = t%p_Nq;
              const int tb = t/p_Nq;

              datafloat tmp = 0;

              occaUnroll(p_gjNq)
                for(int i=0;i<p_gjNq;++i){
                  tmp += s_I[i][ta]*s_v[tb][i];
                }

              const int id = emap*p_Np + c*p_Nq2 + tb*p_Nq + ta;
              Aq[id] = tmp;
            }
          }
        }
      }
  }
}//REF12 ends



