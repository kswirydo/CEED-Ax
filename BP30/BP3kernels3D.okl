//this is a sequwnce of optimizations applied to a full Ax AKA BP3 (benchmark problem 3)
// put together by Kasia for paper
// ONLY 2D versions in this file

#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)


#define p_G00ID 0
#define p_G01ID 1
#define p_G02ID 2
#define p_G11ID 3
#define p_G12ID 4
#define p_G22ID 5
#define p_GWJID 6


//Ref 0, no optimizations and 3 kernel version, as inefficient as I was able to think

kernel void ellipticAxHex3D_Ref3D1( int Nelements,
    datafloat *gjGeo,
    datafloat *  gllD,
    datafloat *  gjI,
    datafloat lambda,
    datafloat * q,
    datafloat * Ixq,
    datafloat *  Aq
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;
    exclusive datafloat r_res;
    shared datafloat s_gsI[p_gjNq][p_Nq];

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
        }//for a
      }// for b
    }//for c

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){

            for(int n=0; n<p_Nq; ++n) {
              int emap = e;


              int t = n + b*p_Nq + c*p_Nq2;
              //we need s_q[c][b][n];
              //and there is A MAPPING
              // remember Q has fewer elements
              Iq += s_gsI[i][n]*q[t+emap*p_Np];
              //s_q[c][b][n];
            }
          }
          //    r_res = Iq;
          int emap = e;
          int t = i + b*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] = Iq;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {

            for(int n=0; n<p_Nq; ++n) {
              int emap = e;
              int t = i + n*p_gjNq + c*p_gjNq2;
              Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
            }
          }
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] = Iq;
        }
      }
    }

    barrier(localMemFence);




    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;

          for(int n=0; n<p_Nq; ++n) {
            int emap = e;
            int t = i + j*p_gjNq + n*p_gjNq2;
            Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
          }
          emap = e;
          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Aq[id] = Iq;

        }
      }
    }
  }



  // at this point q is interpolated in all 3 dim.
  // ------------KERNEL 2 -------------->

  // kernel 2 differentiate on gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    //  shared datafloat s_gllD[p_gjNq][p_Nq];
    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp;
    //  exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
    //  exclusive int emap;

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }

        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)
          int   emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          datafloat    GwJ = gjGeo[base+p_GWJID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;

          for (int n = 0; n<p_gjNq; ++n) {
            dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
            ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
            dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + e*p_gjNp];
          }
          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          int t = i + j*p_gjNq + k*p_gjNq2;

          Ixq[t+emap*p_gjNp] = GwJ*Aq[t+emap*p_gjNp]*lambda;
        }
      }
    }
    barrier(localMemFence);

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int   emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          datafloat    G00 = gjGeo[base+p_G00ID*p_gjNp];
          datafloat    G01 = gjGeo[base+p_G01ID*p_gjNp];
          datafloat    G02 = gjGeo[base+p_G02ID*p_gjNp];
          //  s_q[k][j][i] = r_qr;

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] = G00*r_dr + G01*r_ds + G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;

          for(int m=0; m<p_gjNq; ++m) {
            //k j m
            emap = e;
            int t = m + j*p_gjNq + k*p_gjNq2;
            tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
          }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          datafloat G11 = gjGeo[base+p_G11ID*p_gjNp];
          datafloat G12 = gjGeo[base+p_G12ID*p_gjNp];
          datafloat    G01 = gjGeo[base+p_G01ID*p_gjNp];

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =G01*r_dr + G11*r_ds + G12*r_dt;
        }
      }
    }


    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;

          for(int m=0; m<p_gjNq; ++m) {
            //k m i
            emap = e;
            int t = i + m*p_gjNq + k*p_gjNq2;
            tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
          }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          datafloat    G02 = gjGeo[base+p_G02ID*p_gjNp];
          datafloat G12 = gjGeo[base+p_G12ID*p_gjNp];
          datafloat    G22 = gjGeo[base+p_G22ID*p_gjNp];

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =G02*r_dr + G12*r_ds + G22*r_dt;
        }
      }
    }


    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;

          for(int m=0; m<p_gjNq; ++m) {
            // m j i

            int t = i + j*p_gjNq + m*p_gjNq2;
            tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
          }
          //  r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          Ixq[base] += tmp;

        }
      }
    }
  }//for e
  //-------------------- kernel 3 interpolate back to gll hex ------------------->

  for(int e=0; e<Nelements; ++e; outer0) {
    // read q

    //    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];
    exclusive datafloat r_res;


    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {


          //  s_q[k][j][i] = Ixq[emap*p_gjNp+base];
          if(i<p_Nq &&  k == 0 && j<p_gjNq) {
            s_I[j][i] = gjI[j*p_Nq+i];
          }
          int emap = e;
          int t = i + j*p_gjNq + k*p_gjNq2;
          r_res  = 0.0f;

        }
      }
    }
    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          int emap = e;
          if(c<p_Nq){

            for(int m=0; m<p_gjNq; ++m) {
              // k--> c

              int t = i + j*p_gjNq + m*p_gjNq2;

              Iq += s_I[m][c]*Ixq[t+p_gjNp*emap];
            }
          }
          r_res = Iq;

          //  int t = i + j*p_gjNq + c*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =Iq;
        }
      }
    }

    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_res;
        }
      }
    }
    barrier(localMemFence);
    // r direction

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;
            for(int m=0; m<p_gjNq; ++m) {
              int t = i + m*p_gjNq + c*p_gjNq2;
              Iq += s_I[m][b]*Aq[emap*p_gjNp+t];
            }

            r_res = Iq;

            //  int t = i + b*p_gjNq + c*p_gjNq2;
            //  Ixq[t+emap*p_gjNp] =Iq;
          }
          //  else
          //  {
          //  int t = i + b*p_gjNq + c*p_gjNq2;
          //  Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
          //  }
        }
      }
    }
    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] =r_res;
          //      Aq[t+emap*p_gjNp] = -1.0f;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;
            int emap = e;

            for(int m=0; m<p_gjNq; ++m) {

              int t = m + b*p_gjNq + c*p_gjNq2;

              Iq += s_I[m][a]*Ixq[t+emap*p_gjNp];
            }

            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;

            Aq[base] = Iq;
          }
        }
      }
    }//e
  } //kernel e9

}// REF 0 ends here

//same stuff but 1 kernel version

kernel void ellipticAxHex3D_Ref3D2( int Nelements,
    datafloat *gjGeo,
    datafloat *  gllD,
    datafloat *  gjI,
    datafloat lambda,
    datafloat * q,
    datafloat * Ixq,
    datafloat *  Aq,
    datafloat * Aqres
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;

    shared datafloat s_gsI[p_gjNq][p_Nq];
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp, r_res;

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
        }//for a
      }// for b
    }//for c

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){

            for(int n=0; n<p_Nq; ++n) {
              int emap = e;


              int t = n + b*p_Nq + c*p_Nq2;
              //we need s_q[c][b][n];
              //and there is A MAPPING
              // remember Q has fewer elements


              Iq += s_gsI[i][n]*q[t+emap*p_Np];
              //s_q[c][b][n];
            }
          }
          //    r_res = Iq;
          int emap = e;
          int t = i + b*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] = Iq;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {

            for(int n=0; n<p_Nq; ++n) {
              int emap = e;
              int t = i + n*p_gjNq + c*p_gjNq2;
              Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
            }
          }
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] = Iq;
          //    r_res = Iq;
        }
      }
    }

    barrier(localMemFence);




    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;

          for(int n=0; n<p_Nq; ++n) {
            int emap = e;
            int t = i + j*p_gjNq + n*p_gjNq2;
            Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
          }
          //  r_res = Iq;
          //    s_q[k][j][i] = Iq;
          emap = e;
          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Aq[id] = Iq;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }

        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)
          int   emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          datafloat    GwJ = gjGeo[base+p_GWJID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;

          for (int n = 0; n<p_gjNq; ++n) {
            dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
            ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
            dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + e*p_gjNp];
          }
          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          int t = i + j*p_gjNq + k*p_gjNq2;

          Ixq[t+emap*p_gjNp] = GwJ*Aq[t+emap*p_gjNp]*lambda;
        }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int   emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          datafloat    G00 = gjGeo[base+p_G00ID*p_gjNp];
          datafloat    G01 = gjGeo[base+p_G01ID*p_gjNp];
          datafloat    G02 = gjGeo[base+p_G02ID*p_gjNp];
          //  s_q[k][j][i] = r_qr;

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] = G00*r_dr + G01*r_ds + G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;

          for(int m=0; m<p_gjNq; ++m) {
            //k j m
            emap = e;
            int t = m + j*p_gjNq + k*p_gjNq2;
            tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
          }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          datafloat G11 = gjGeo[base+p_G11ID*p_gjNp];
          datafloat G12 = gjGeo[base+p_G12ID*p_gjNp];
          datafloat    G01 = gjGeo[base+p_G01ID*p_gjNp];

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =G01*r_dr + G11*r_ds + G12*r_dt;
          //s_q[k][j][i] = r_qs;
        }
      }
    }

    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;

          for(int m=0; m<p_gjNq; ++m) {
            //k m i
            emap = e;
            int t = i + m*p_gjNq + k*p_gjNq2;
            tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
          }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          datafloat    G02 = gjGeo[base+p_G02ID*p_gjNp];
          datafloat G12 = gjGeo[base+p_G12ID*p_gjNp];
          datafloat    G22 = gjGeo[base+p_G22ID*p_gjNp];

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =G02*r_dr + G12*r_ds + G22*r_dt;
          //    s_q[k][j][i] = r_qt;
        }
      }
    }

    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          r_res =0.0f;
          int emap = e;

          for(int m=0; m<p_gjNq; ++m) {
            // m j i

            int t = i + j*p_gjNq + m*p_gjNq2;
            tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
          }
          //  r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          Ixq[base] += tmp;
        }
      }
    }





    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          int emap = e;
          if(c<p_Nq){

            for(int m=0; m<p_gjNq; ++m) {
              // k--> c

              int t = i + j*p_gjNq + m*p_gjNq2;

              Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
            }
          }
          r_res = Iq;

        }
      }
    }

    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_res;
        }
      }
    }
    barrier(localMemFence);

    // r direction

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;
            for(int m=0; m<p_gjNq; ++m) {
              int t = i + m*p_gjNq + c*p_gjNq2;
              Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
            }
            r_res = Iq;
          }
        }
      }
    }
    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] =r_res;
          //            Aq[t+emap*p_gjNp] = -1.0f;
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;
            int emap = e;

            for(int m=0; m<p_gjNq; ++m) {

              int t = m + b*p_gjNq + c*p_gjNq2;

              Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
            }

            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;

            Aqres[base] = Iq;
          }
        }
      }
    }//e
  } //kernel e9


}//REF 1 ends here
//REF2: const variables, loop unrolling

kernel void ellipticAxHex3D_Ref3D3(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq,
    datafloat * Aqres
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;

    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp, r_res;

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          int emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;

        }//for a
      }// for b
    }//for c

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                int emap = e;


                int t = n + b*p_Nq + c*p_Nq2;
                //we need s_q[c][b][n];
                //and there is A MAPPING
                // remember Q has fewer elements


                Iq += s_gsI[i][n]*q[t+emap*p_Np];
                //s_q[c][b][n];
              }
          }
          //    r_res = Iq;
          int emap = e;
          int t = i + b*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] = Iq;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                int emap = e;
                int t = i + n*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
              }
          }
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] = Iq;
          //    r_res = Iq;
        }
      }
    }

    barrier(localMemFence);




    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {
              int emap = e;
              int t = i + j*p_gjNq + n*p_gjNq2;
              Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
            }
          //  r_res = Iq;
          //    s_q[k][j][i] = Iq;
          emap = e;
          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Aq[id] = Iq;

        }
      }
    }
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }

        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)
          int   emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          datafloat    GwJ = gjGeo[base+p_GWJID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
              ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
              dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + e*p_gjNp];
            }
          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          int t = i + j*p_gjNq + k*p_gjNq2;

          Ixq[t+emap*p_gjNp] = GwJ*Aq[t+emap*p_gjNp]*lambda;
        }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int   emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          datafloat    G00 = gjGeo[base+p_G00ID*p_gjNp];
          datafloat    G01 = gjGeo[base+p_G01ID*p_gjNp];
          datafloat    G02 = gjGeo[base+p_G02ID*p_gjNp];
          //  s_q[k][j][i] = r_qr;

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] = G00*r_dr + G01*r_ds + G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k j m
              emap = e;
              int t = m + j*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
            }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          datafloat G11 = gjGeo[base+p_G11ID*p_gjNp];
          datafloat G12 = gjGeo[base+p_G12ID*p_gjNp];
          datafloat G01 = gjGeo[base+p_G01ID*p_gjNp];

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =G01*r_dr + G11*r_ds + G12*r_dt;
          //s_q[k][j][i] = r_qs;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k m i
              emap = e;
              int t = i + m*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
            }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          datafloat    G02 = gjGeo[base+p_G02ID*p_gjNp];
          datafloat    G12 = gjGeo[base+p_G12ID*p_gjNp];
          datafloat    G22 = gjGeo[base+p_G22ID*p_gjNp];

          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =G02*r_dr + G12*r_ds + G22*r_dt;
          //    s_q[k][j][i] = r_qt;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          r_res =0.0f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              // m j i

              int t = i + j*p_gjNq + m*p_gjNq2;
              tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
            }
          //  r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          Ixq[base] += tmp;
        }
      }
    }





    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          int emap = e;
          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c

                int t = i + j*p_gjNq + m*p_gjNq2;

                Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
              }
          }
          r_res = Iq;

          //  int t = i + j*p_gjNq + c*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =Iq;
        }
      }
    }

    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_res;
        }
      }
    }

    barrier(localMemFence);





    // r direction

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;

            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = i + m*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
              }

            r_res = Iq;

            //  int t = i + b*p_gjNq + c*p_gjNq2;
            //  Ixq[t+emap*p_gjNp] =Iq;
          }
          //  else
          //  {
          //  int t = i + b*p_gjNq + c*p_gjNq2;
          //  Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
          //  }
        }
      }
    }
    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          int emap = e;
          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] =r_res;
          //Aq[t+emap*p_gjNp] = 0.0f;
        }
      }
    }

    barrier(localMemFence);


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;
            int emap = e;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = m + b*p_gjNq + c*p_gjNq2;

                Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
              }

            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
            Aqres[base] = Iq;
          }
        }
      }

    }//e
  } //kernel e9

}//REF 2 ends here

//REF3

// load geometric factors to registers.
// declare 'emap' only once


kernel void ellipticAxHex3D_Ref3D4(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq,
    datafloat * Aqres
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;

    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp, r_res;
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;

        }//for a
      }// for b
    }//for c

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {



                int t = n + b*p_Nq + c*p_Nq2;
                //we need s_q[c][b][n];
                //and there is A MAPPING
                // remember Q has fewer elements


                Iq += s_gsI[i][n]*q[t+emap*p_Np];
                //s_q[c][b][n];
              }
          }
          //    r_res = Iq;

          int t = i + b*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] = Iq;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {

                int t = i + n*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
              }
          }

          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] = Iq;
          //    r_res = Iq;
        }
      }
    }

    barrier(localMemFence);




    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {

              int t = i + j*p_gjNq + n*p_gjNq2;
              Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
            }
          //  r_res = Iq;
          //    s_q[k][j][i] = Iq;

          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Aq[id] = Iq;

        }
      }
    }
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }

        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          r_G22 = gjGeo[base+p_G22ID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n]*Aq[n + j*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
              ds += s_gjD[j][n]*Aq[i + n*p_gjNq + k*p_gjNq*p_gjNq + e*p_gjNp];
              dt += s_gjD[k][n]*Aq[i + j*p_gjNq + n*p_gjNq*p_gjNq + e*p_gjNp];
            }
          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          int t = i + j*p_gjNq + k*p_gjNq2;

          Ixq[t+emap*p_gjNp] = r_GwJ*Aq[t+emap*p_gjNp]*lambda;
        }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  s_q[k][j][i] = r_qr;

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k j m

              int t = m + j*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][i]*Aq[t+p_gjNp*emap];
            }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
          //s_q[k][j][i] = r_qs;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k m i

              int t = i + m*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][j]*Aq[t+emap*p_gjNp];
            }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          int t = i + j*p_gjNq + k*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
          //    s_q[k][j][i] = r_qt;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          r_res =0.0f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              // m j i

              int t = i + j*p_gjNq + m*p_gjNq2;
              tmp += s_gjD[m][k]*Aq[t+emap*p_gjNp];
            }
          //  r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          Ixq[base] += tmp;
        }
      }
    }





    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;

          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c

                int t = i + j*p_gjNq + m*p_gjNq2;

                Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
              }
          }
          r_res = Iq;

          //  int t = i + j*p_gjNq + c*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =Iq;
        }
      }
    }

    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int t = i + j*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_res;
        }
      }
    }


    barrier(localMemFence);




    // r direction

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;

            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = i + m*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
              }

            r_res = Iq;

            //  int t = i + b*p_gjNq + c*p_gjNq2;
            //  Ixq[t+emap*p_gjNp] =Iq;
          }
          //  else
          //  {
          //  int t = i + b*p_gjNq + c*p_gjNq2;
          //  Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
          //  }
        }
      }
    }
    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] =r_res;
          //Aq[t+emap*p_gjNp] = 0.0f;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;

            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = m + b*p_gjNq + c*p_gjNq2;

                Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
              }

            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
            Aqres[base] = Iq;
          }
        }
      }

    }//e
  } //kernel e9

}//REF 3 ends here

//REF 4 -- used shared memory array just for differentiation, to store patial result.u
kernel void ellipticAxHex3D_Ref3D5(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq,
    datafloat * Aqres
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp, r_res;
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;

        }//for a
      }// for b
    }//for c

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {



                int t = n + b*p_Nq + c*p_Nq2;
                //we need s_q[c][b][n];
                //and there is A MAPPING
                // remember Q has fewer elements


                Iq += s_gsI[i][n]*q[t+emap*p_Np];
                //s_q[c][b][n];
              }
          }
          //    r_res = Iq;

          int t = i + b*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] = Iq;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {

                int t = i + n*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
              }
          }

          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] = Iq;
          //    r_res = Iq;
        }
      }
    }

    barrier(localMemFence);




    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {

              int t = i + j*p_gjNq + n*p_gjNq2;
              Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
            }
          //  r_res = Iq;
          //    s_q[k][j][i] = Iq;

          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Aq[id] = Iq;

        }
      }
    }
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }
          int t = i + j*p_gjNq + k*p_gjNq2;
          s_q[k][j][i] = Aq[emap*p_gjNp+t];
        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          r_G22 = gjGeo[base+p_G22ID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n] * s_q[k][j][n];
              ds += s_gjD[j][n]*s_q[k][n][i];
              dt += s_gjD[k][n]*s_q[n][j][i];
            }


          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          int t = i + j*p_gjNq + k*p_gjNq2;

          Ixq[t+emap*p_gjNp] = r_GwJ*s_q[k][j][i]*lambda;
        }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  s_q[k][j][i] = r_qr;

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp]
          s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k j m

              //      int t = m + j*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][i]*s_q[k][j][m];
            }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =
          s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
          //s_q[k][j][i] = r_qs;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k m i
              //  emap = e;
              //  int t = i + m*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][j]*s_q[k][m][i];
            }

          int t = i + j*p_gjNq + k*p_gjNq2;
          Ixq[t+emap*p_gjNp] +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {

          //    int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //    int t = i + j*p_gjNq + k*p_gjNq2;
          //    Aq[t+emap*p_gjNp] =

          s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
          //    s_q[k][j][i] = r_qt;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          r_res =0.0f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              // m j i

              //  int t = i + j*p_gjNq + m*p_gjNq2;
              tmp += s_gjD[m][k]*s_q[m][j][i];
            }
          //  r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          Ixq[base] += tmp;
        }
      }
    }





    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;

          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c

                int t = i + j*p_gjNq + m*p_gjNq2;

                Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
              }
          }
          r_res = Iq;

          //  int t = i + j*p_gjNq + c*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =Iq;
        }
      }
    }

    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int t = i + j*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_res;
        }
      }
    }




    barrier(localMemFence);


    // r direction

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;

            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = i + m*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
              }

            r_res = Iq;

            //  int t = i + b*p_gjNq + c*p_gjNq2;
            //  Ixq[t+emap*p_gjNp] =Iq;
          }
          //  else
          //  {
          //  int t = i + b*p_gjNq + c*p_gjNq2;
          //  Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
          //  }
        }
      }
    }
    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] =r_res;
          //Aq[t+emap*p_gjNp] = 0.0f;
        }
      }
    }

    barrier(localMemFence);


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;

            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = m + b*p_gjNq + c*p_gjNq2;

                Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
              }

            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
            Aqres[base] = Iq;
          }
        }
      }

    }//e
  } //kernel e9

}//REF 4 ends here

//REF5 - register variable instead of global load in differentiation


kernel void ellipticAxHex3D_Ref3D6(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq,
    datafloat * restrict Aqres
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp, r_res;
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;

        }//for a
      }// for b
    }//for c

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {



                int t = n + b*p_Nq + c*p_Nq2;
                //we need s_q[c][b][n];
                //and there is A MAPPING
                // remember Q has fewer elements


                Iq += s_gsI[i][n]*q[t+emap*p_Np];
                //s_q[c][b][n];
              }
          }
          //    r_res = Iq;

          int t = i + b*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] = Iq;
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {

                int t = i + n*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[j][n]*Aq[emap*p_gjNp+t];
              }
          }

          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] = Iq;
          //    r_res = Iq;
        }
      }
    }

    barrier(localMemFence);




    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {

              int t = i + j*p_gjNq + n*p_gjNq2;
              Iq += s_gsI[k][n]*Ixq[t+emap*p_gjNp];
            }
          //  r_res = Iq;
          //    s_q[k][j][i] = Iq;

          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Aq[id] = Iq;

        }
      }
    }
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }
          int t = i + j*p_gjNq + k*p_gjNq2;
          s_q[k][j][i] = Aq[emap*p_gjNp+t];
        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          r_G22 = gjGeo[base+p_G22ID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n] * s_q[k][j][n];
              ds += s_gjD[j][n]*s_q[k][n][i];
              dt += s_gjD[k][n]*s_q[n][j][i];
            }


          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          //    int t = i + j*p_gjNq + k*p_gjNq2;

          //  Ixq[t+emap*p_gjNp]
          r_tmp = r_GwJ*s_q[k][j][i]*lambda;
        }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  s_q[k][j][i] = r_qr;

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp]
          s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k j m

              //      int t = m + j*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][i]*s_q[k][j][m];
            }

          //      int t = i + j*p_gjNq + k*p_gjNq2;
          //  Ixq[t+emap*p_gjNp] +=tmp;
          r_tmp +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =
          s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
          //s_q[k][j][i] = r_qs;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k m i
              //  emap = e;
              //  int t = i + m*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][j]*s_q[k][m][i];
            }

          //      int t = i + j*p_gjNq + k*p_gjNq2;
          //    Ixq[t+emap*p_gjNp] +=tmp;
          r_tmp +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {

          //    int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //    int t = i + j*p_gjNq + k*p_gjNq2;
          //    Aq[t+emap*p_gjNp] =

          s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
          //    s_q[k][j][i] = r_qt;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          r_res =0.0f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              // m j i

              //  int t = i + j*p_gjNq + m*p_gjNq2;
              tmp += s_gjD[m][k]*s_q[m][j][i];
            }
          r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          Ixq[base] =r_tmp;
          //+= tmp;
        }
      }
    }





    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;

          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c

                int t = i + j*p_gjNq + m*p_gjNq2;

                Iq += s_gsI[m][c]*Ixq[t+p_gjNp*emap];
              }
          }
          r_res = Iq;

          //  int t = i + j*p_gjNq + c*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =Iq;
        }
      }
    }

    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int t = i + j*p_gjNq + c*p_gjNq2;
          Aq[t+emap*p_gjNp] =r_res;
        }
      }
    }


    barrier(localMemFence);




    // r direction

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;

            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = i + m*p_gjNq + c*p_gjNq2;
                Iq += s_gsI[m][b]*Aq[emap*p_gjNp+t];
              }

            r_res = Iq;

            //  int t = i + b*p_gjNq + c*p_gjNq2;
            //  Ixq[t+emap*p_gjNp] =Iq;
          }
          //  else
          //  {
          //  int t = i + b*p_gjNq + c*p_gjNq2;
          //  Ixq[t+emap*p_gjNp]  = Aq[t+emap*p_gjNp];
          //  }
        }
      }
    }
    barrier(localMemFence);
    barrier(localMemFence);
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int t = i + j*p_gjNq + c*p_gjNq2;
          Ixq[t+emap*p_gjNp] =r_res;
          // Aq[t+emap*p_gjNp] = 0.0f;
        }
      }
    }

    barrier(localMemFence);


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;

            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {

                int t = m + b*p_gjNq + c*p_gjNq2;

                Iq += s_gsI[m][a]*Ixq[t+emap*p_gjNp];
              }

            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
            Aqres[base] = Iq;
          }
        }
      }

    }//e
  }

}//REF5 ends here

//REF6 global storage only BETWEEN parts


kernel void ellipticAxHex3D_Ref3D7(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp, r_res;
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;
          if (t<p_Np) {
            int ta = t%p_Nq;
            int tb = (t/p_Nq)%p_Nq;
            int tc = (t/p_Nq2)%p_Nq;
            s_q[tc][tb][ta] = q[emap*p_Np+t];
          }//if

        }//for a
      }// for b
    }//for c


    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                Iq += s_gsI[i][n]*s_q[c][b][n];
              }
          }
          r_res = Iq;     
        }
      }
    }


    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][b][i] = r_res;
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                Iq += s_gsI[j][n]*s_q[c][n][i];
              }
          }
          r_res = Iq;
        }
      }
    }
    barrier(localMemFence);



    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][j][i] = r_res;
        }
      }
    }
    barrier(localMemFence);

    // t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {
              Iq += s_gsI[k][n]*s_q[n][j][i];
            }
          //  r_res = Iq;
          //    s_q[k][j][i] = Iq;
          emap = e;
          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Aq[id] = Iq;
          //s_q[k][j][i];
        }
      }
    }


    //differentiate
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }
          int t = i + j*p_gjNq + k*p_gjNq2;
          s_q[k][j][i] = Aq[emap*p_gjNp+t];
        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          r_G22 = gjGeo[base+p_G22ID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n] * s_q[k][j][n];
              ds += s_gjD[j][n]*s_q[k][n][i];
              dt += s_gjD[k][n]*s_q[n][j][i];
            }


          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          //    int t = i + j*p_gjNq + k*p_gjNq2;

          //  Ixq[t+emap*p_gjNp]
          r_tmp = r_GwJ*s_q[k][j][i]*lambda;
        }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  s_q[k][j][i] = r_qr;

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp]
          s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k j m

              //      int t = m + j*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][i]*s_q[k][j][m];
            }

          //      int t = i + j*p_gjNq + k*p_gjNq2;
          //  Ixq[t+emap*p_gjNp] +=tmp;
          r_tmp +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =
          s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
          //s_q[k][j][i] = r_qs;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k m i
              //  emap = e;
              //  int t = i + m*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][j]*s_q[k][m][i];
            }

          //      int t = i + j*p_gjNq + k*p_gjNq2;
          //    Ixq[t+emap*p_gjNp] +=tmp;
          r_tmp +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {

          //    int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //    int t = i + j*p_gjNq + k*p_gjNq2;
          //    Aq[t+emap*p_gjNp] =

          s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
          //    s_q[k][j][i] = r_qt;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          r_res =0.0f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              // m j i

              //  int t = i + j*p_gjNq + m*p_gjNq2;
              tmp += s_gjD[m][k]*s_q[m][j][i];
            }
          r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          Ixq[base] =r_tmp;
          //+= tmp;
        }
      }
    }





    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
          emap =e;
          s_q[k][j][i] = Ixq[emap*p_gjNp+base];

        }
      }
    }
    barrier(localMemFence);



    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c
                Iq += s_gsI[m][c]*s_q[m][j][i];
              }
          }
          r_res = Iq;
        }
      }
    }

    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][j][i] = r_res;
        }
      }
    }




    // r direction
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_gsI[m][b]*s_q[c][m][i];
              }
            r_res = Iq;
          }
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][b][i]= r_res;
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_gsI[m][a]*s_q[c][b][m];
              }
            emap = e;
            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
            Aq[base] = Iq;
          }
        }
      }
    }
  }

}//REF6 ends here

//REF7 - no global storage

kernel void ellipticAxHex3D_Ref3D8(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    //  shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    exclusive datafloat r_dr, r_ds, r_dt, r_tmp, r_res;
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //  r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;
          if (t<p_Np) {
            int ta = t%p_Nq;
            int tb = (t/p_Nq)%p_Nq;
            int tc = (t/p_Nq2)%p_Nq;
            s_q[tc][tb][ta] = q[emap*p_Np+t];
          }//if

        }//for a
      }// for b
    }//for c

    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                Iq += s_gsI[i][n]*s_q[c][b][n];
              }
          }
          r_res = Iq;     a
        }
      }
    }

    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][b][i] = r_res;
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                Iq += s_gsI[j][n]*s_q[c][n][i];
              }
          }
          r_res = Iq;
        }
      }
    }
    barrier(localMemFence);



    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][j][i] = r_res;
        }
      }
    }
    barrier(localMemFence);

    // t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {
              Iq += s_gsI[k][n]*s_q[n][j][i];
            }
          r_res = Iq;
          //    s_q[k][j][i] = Iq;
          emap = e;
          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          //  Aq[id] = Iq;
          //s_q[k][j][i];
        }
      }
    }


    //differentiate
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }
          int t = i + j*p_gjNq + k*p_gjNq2;
          s_q[k][j][i] = r_res;
          Aq[emap*p_gjNp+t];
        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)

          int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          r_G22 = gjGeo[base+p_G22ID*p_gjNp];


          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n] * s_q[k][j][n];
              ds += s_gjD[j][n]*s_q[k][n][i];
              dt += s_gjD[k][n]*s_q[n][j][i];
            }


          r_dr = dr;
          r_ds = ds;
          r_dt = dt;

          //  emap = e;
          //    int t = i + j*p_gjNq + k*p_gjNq2;

          //  Ixq[t+emap*p_gjNp]
          r_tmp = r_GwJ*s_q[k][j][i]*lambda;
        }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  s_q[k][j][i] = r_qr;

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp]
          s_q[k][j][i] = r_G00*r_dr + r_G01*r_ds + r_G02*r_dt;;

        }
      }
    }

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          int emap = e;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k j m

              //      int t = m + j*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][i]*s_q[k][j][m];
            }

          //      int t = i + j*p_gjNq + k*p_gjNq2;
          //  Ixq[t+emap*p_gjNp] +=tmp;
          r_tmp +=tmp;
        }
      }
    }

    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          //  int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //  int t = i + j*p_gjNq + k*p_gjNq2;
          //  Aq[t+emap*p_gjNp] =
          s_q[k][j][i] = r_G01*r_dr + r_G11*r_ds + r_G12*r_dt;
          //s_q[k][j][i] = r_qs;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              //k m i
              //  emap = e;
              //  int t = i + m*p_gjNq + k*p_gjNq2;
              tmp += s_gjD[m][j]*s_q[k][m][i];
            }

          //      int t = i + j*p_gjNq + k*p_gjNq2;
          //    Ixq[t+emap*p_gjNp] +=tmp;
          r_tmp +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {

        for(int i=0; i<p_gjNq; ++i; inner0) {

          //    int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;


          //    int t = i + j*p_gjNq + k*p_gjNq2;
          //    Aq[t+emap*p_gjNp] =

          s_q[k][j][i] = r_G02*r_dr + r_G12*r_ds + r_G22*r_dt;
          //    s_q[k][j][i] = r_qt;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          r_res =0.0f;

          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              // m j i

              //  int t = i + j*p_gjNq + m*p_gjNq2;
              tmp += s_gjD[m][k]*s_q[m][j][i];
            }
          r_tmp +=tmp;

          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

          //      Ixq[base] =r_tmp;
          //+= tmp;
        }
      }
    }





    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
          emap =e;
          s_q[k][j][i] = r_tmp;
          //Ixq[emap*p_gjNp+base];

        }
      }
    }
    barrier(localMemFence);



    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c
                Iq += s_gsI[m][c]*s_q[m][j][i];
              }
          }
          r_res = Iq;
        }
      }
    }

    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][j][i] = r_res;
        }
      }
    }




    // r direction
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_gsI[m][b]*s_q[c][m][i];
              }
            r_res = Iq;
          }
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][b][i]= r_res;
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_gsI[m][a]*s_q[c][b][m];
              }
            emap = e;
            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
            Aq[base] = Iq;
          }
        }
      }
    }
  }

}//REF7 ends here

//REF8 all partial results stored in shared
kernel void ellipticAxHex3D_Ref3D9(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){
  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    //  exclusive int emap;
    //  exclusive datafloat r_res;
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_q1[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_q2[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_q3[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_i4[p_gjNq][p_gjNq][p_gjNq];

    shared datafloat s_gjD[p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          //    r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          if (c==0 ) {
            s_gjD[b][a] = gllD[b*p_gjNq+a];
          }

          int emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;
          if (t<p_Np) {
            int ta = t%p_Nq;
            int tb = (t/p_Nq)%p_Nq;
            int tc = (t/p_Nq2)%p_Nq;
            s_q2[tc][tb][ta] = q[emap*p_Np+t];
            
          }//if
        }//for a
      }// for b
    }//for c
    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //    datafloat Iq = 0.0f;
          s_q[c][b][i] = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                s_q[c][b][i] += s_gsI[i][n]*s_q2[c][b][n];
              }
          }

        }
      }
    }

    barrier(localMemFence);


    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //  datafloat Iq = 0.0f;
          s_q2[c][j][i] = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                s_q2[c][j][i] += s_gsI[j][n]*s_q[c][n][i];
              }
          }

        }
      }
    }
    barrier(localMemFence);



    // t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //  datafloat Iq = 0.0f;
          s_q[k][j][i] =0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {
              s_q[k][j][i] += s_gsI[k][n]*s_q2[n][j][i];
            }

        }
      }
    }


    // at this point q is interpolated in all 3 dim.
    // ------------KERNEL 2 -------------->

    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)
          datafloat qr, qs, qt, tmp;
          datafloat G00, G01, G02, G11, G12, G22, GwJ;
          int emap=e;

          const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          GwJ = gjGeo[base+p_GWJID*p_gjNp];



          G00 = gjGeo[base+p_G00ID*p_gjNp];
          G01 = gjGeo[base+p_G01ID*p_gjNp];
          G02 = gjGeo[base+p_G02ID*p_gjNp];

          G11 = gjGeo[base+p_G11ID*p_gjNp];
          G12 = gjGeo[base+p_G12ID*p_gjNp];
          G22 = gjGeo[base+p_G22ID*p_gjNp];
          // now, put together dq/dr, qq/ds, dq/dt and dq/dI

          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n] * s_q[k][j][n];
              ds += s_gjD[j][n] * s_q[k][n][i];
              dt += s_gjD[k][n] * s_q[n][j][i];
            }
          qr = G00*dr + G01*ds + G02*dt;
          qs = G01*dr + G11*ds + G12*dt;
          qt = G02*dr + G12*ds + G22*dt;

          tmp = GwJ*s_q[k][j][i]*lambda;

          s_q1[k][j][i] = qr;
          s_q2[k][j][i] = qs;
          s_q3[k][j][i] = qt;
          s_i4[k][j][i] = tmp;
          //   int idx = e*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          // Aq[idx] = GwJ;
        
}
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq



    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              tmp += s_gjD[m][i]*s_q1[k][j][m];
              tmp += s_gjD[m][j]*s_q2[k][m][i];
              tmp += s_gjD[m][k]*s_q3[m][j][i];
            }
          s_i4[k][j][i]+=tmp;

          s_q[k][j][i] =  s_i4[k][j][i];

        }
      }
    }

    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c
                Iq += s_gsI[m][c]*s_q[m][j][i];
              }
          }
          //r_res = Iq;
          s_q2[c][j][i] = Iq;

        }
      }
    }
    // r direction
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_gsI[m][b]*s_q2[c][m][i];
              }

            s_q[c][b][i] = Iq;
          }
        }
      }
    }
    barrier(localMemFence);




    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_gsI[m][a]*s_q[c][b][m];
              }
            int emap = e;
            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
           Aq[base] = Iq;
          }
        }
      }
    }
  }//e
} //REF8



// for refeence and testing

kernel void ellipticAxHex3D_e9(const int Nelements,
    const datafloat * restrict gjGeo,
    const datafloat * restrict gllD,
    const datafloat * restrict gjI,
    const datafloat lambda,
    datafloat * restrict q,
    datafloat * restrict Ixq,
    datafloat * restrict Aq
    ){


  // load q into shared first
  //kernel 1 - interpolate to gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    exclusive int emap;
    exclusive datafloat r_res;
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_gsI[p_gjNq][p_Nq];
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          r_res =0.0f;
          if (c == 0 && a<p_Nq && b<p_gjNq) {
            s_gsI[b][a] = gjI[b*p_Nq+a];
          }
          emap = e;
          int t = a + b*p_gjNq + c*p_gjNq2;
          if (t<p_Np) {
            int ta = t%p_Nq;
            int tb = (t/p_Nq)%p_Nq;
            int tc = t/p_Nq2;
            s_q[tc][tb][ta] = q[emap*p_Np+t];
          }//if
        }//for a
      }// for b
    }//for c
    //synch threads
    barrier(localMemFence);
    //============== interpolate in 3 dir ========================
    // r --> s --> t
    // rrrrrrr
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if (c<p_Nq && b<p_Nq){
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                Iq += s_gsI[i][n]*s_q[c][b][n];
              }
          }
          r_res = Iq;     a
        }
      }
    }

    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][b][i] = r_res;
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq) {
            occaUnroll(p_Nq)
              for(int n=0; n<p_Nq; ++n) {
                Iq += s_gsI[j][n]*s_q[c][n][i];
              }
          }
          r_res = Iq;
        }
      }
    }
    barrier(localMemFence);



    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][j][i] = r_res;
        }
      }
    }
    barrier(localMemFence);

    // t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n) {
              Iq += s_gsI[k][n]*s_q[n][j][i];
            }
          //  r_res = Iq;
          //    s_q[k][j][i] = Iq;
          emap = e;
          const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
          Ixq[id] = Iq;

          //s_q[k][j][i];
        }
      }
    }
  }// for e


  // at this point q is interpolated in all 3 dim.
  // ------------KERNEL 2 -------------->

  // kernel 2 differentiate on gj hex
  for(int e=0; e<Nelements; ++e; outer0) {
    shared datafloat s_gjD[p_gjNq][p_gjNq];
    shared datafloat s_gllD[p_gjNq][p_Nq];
    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    exclusive datafloat r_qr, r_qs, r_qt, r_tmp;
    exclusive datafloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
    exclusive int emap;

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          // D to shared, q to shared,
          if (k==0 ) {
            s_gjD[j][i] = gllD[j*p_gjNq+i];
          }
          emap = e;
          int t = i + j*p_gjNq + k*p_gjNq2;
          s_q[k][j][i] = Ixq[emap*p_gjNp+t];
        }//for i
      }//for j
    }//for k
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          //load geofactors for my (k,j,i)
          //    emap = e;
          const int base = emap*p_Ngeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          //geofactors for k j i thread
          r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
          r_G00 = gjGeo[base+p_G00ID*p_gjNp];
          r_G01 = gjGeo[base+p_G01ID*p_gjNp];
          r_G02 = gjGeo[base+p_G02ID*p_gjNp];

          r_G11 = gjGeo[base+p_G11ID*p_gjNp];
          r_G12 = gjGeo[base+p_G12ID*p_gjNp];
          r_G22 = gjGeo[base+p_G22ID*p_gjNp];
          // now, put together dq/dr, qq/ds, dq/dt and dq/dI

          datafloat dr = 0.0f;
          datafloat ds = 0.0f;
          datafloat dt = 0.0f;
          occaUnroll(p_gjNq)
            for (int n = 0; n<p_gjNq; ++n) {
              dr += s_gjD[i][n] * s_q[k][j][n];
              ds += s_gjD[j][n]*s_q[k][n][i];
              dt += s_gjD[k][n]*s_q[n][j][i];
            }
          r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
          r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
          r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

          r_tmp = r_GwJ*s_q[k][j][i]*lambda;
           // int idx  = e*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          // Aq[idx] = r_GwJ;;
  
      }
      }
    }
    barrier(localMemFence);
    // Multiply by D^T, size p_Nq x p_gjNq
    // D size p_gjNq x p_Nq

    // r direction
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[k][j][i] = r_qr;
        }
      }
    }
    barrier(localMemFence);

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              tmp += s_gjD[m][i]*s_q[k][j][m];
            }
          r_tmp +=tmp;
        }
      }
    }
    barrier(localMemFence);

    //s direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[k][j][i] = r_qs;
        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              tmp += s_gjD[m][j]*s_q[k][m][i];
            }
          r_tmp +=tmp;
        }
      }
    }
    barrier(localMemFence);
    //t direction

    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[k][j][i] = r_qt;

        }
      }
    }
    barrier(localMemFence);
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat tmp = 0.f;
          occaUnroll(p_gjNq)
            for(int m=0; m<p_gjNq; ++m) {
              tmp += s_gjD[m][k]*s_q[m][j][i];
            }
          r_tmp +=tmp;
          int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
          Ixq[base] = r_tmp;
//Aq[base] = r_tmp;
        }
      }
    }
  }//for e


  //-------------------- kernel 3 interpolate back to gll hex ------------------->

  for(int e=0; e<Nelements; ++e; outer0) {
    // read q

    shared datafloat s_q[p_gjNq][p_gjNq][p_gjNq];
    shared datafloat s_I[p_gjNq][p_Nq];
    exclusive datafloat r_res = 0.0f, r_Aq=0.0f;
    int emap;
    for(int k=0; k<p_gjNq; ++k; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {

          int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
          emap =e;
          s_q[k][j][i] = Ixq[emap*p_gjNp+base];
          if(i<p_Nq &&  k == 0 && j<p_gjNq) {
            s_I[j][i] = gjI[j*p_Nq+i];
          }
        }
      }
    }
    barrier(localMemFence);


    // t first
    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          datafloat Iq = 0.0f;
          if(c<p_Nq){
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                // k--> c
                Iq += s_I[m][c]*s_q[m][j][i];
              }
          }
          r_res = Iq;
        }
      }
    }

    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int j=0; j<p_gjNq; ++j; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][j][i] = r_res;
        }
      }
    }




    // r direction
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          if(c<p_Nq && b<p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_I[m][b]*s_q[c][m][i];
              }
            r_res = Iq;
          }
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int i=0; i<p_gjNq; ++i; inner0) {
          s_q[c][b][i]= r_res;
        }
      }
    }
    barrier(localMemFence);

    for(int c=0; c<p_gjNq; ++c; inner2) {
      for(int b=0; b<p_gjNq; ++b; inner1) {
        for(int a=0; a<p_gjNq; ++a; inner0) {
          if (c<p_Nq && b<p_Nq && a< p_Nq){
            datafloat Iq = 0.0f;
            occaUnroll(p_gjNq)
              for(int m=0; m<p_gjNq; ++m) {
                Iq += s_I[m][a]*s_q[c][b][m];
              }
            emap = e;
            int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
            Aq[base] = Iq;
          }
        }
      }
    }
  }//e
} //kernel e9







